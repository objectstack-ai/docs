---
title: Server SDK Reference
description: Complete API reference for ObjectQL server-side SDK
---

# Server SDK Reference

Complete reference for the ObjectQL server-side SDK, covering initialization, query methods, mutations, and advanced features.

## Installation

```bash
npm install @objectql/core
```

## Initialization

### new ObjectQL()

Create a new ObjectQL instance.

```typescript
import { ObjectQL } from '@objectql/core'

const db = new ObjectQL(options: ObjectQLOptions)
```

#### ObjectQLOptions

```typescript
interface ObjectQLOptions {
  // Database driver
  driver: 'sqlite' | 'mysql' | 'postgresql' | 'mssql' | 'oracle'
  
  // Connection URL
  url?: string
  
  // Or individual connection parameters
  host?: string
  port?: number
  user?: string
  password?: string
  database?: string
  
  // Driver-specific options
  sqlite?: SQLiteOptions
  mysql?: MySQLOptions
  postgres?: PostgresOptions
  
  // ObjectQL options
  enableVirtualColumns?: boolean  // Default: true for SQLite
  enableCache?: boolean           // Default: true
  cacheSize?: number              // Default: 1000
  logLevel?: 'debug' | 'info' | 'warn' | 'error'  // Default: 'info'
}
```

#### Examples

**SQLite (Local Development):**

```typescript
const db = new ObjectQL({
  driver: 'sqlite',
  url: './data/myapp.db'
})
```

**MySQL (Production):**

```typescript
const db = new ObjectQL({
  driver: 'mysql',
  host: 'db.example.com',
  port: 3306,
  user: 'myapp',
  password: process.env.DB_PASSWORD,
  database: 'production',
  mysql: {
    connectionLimit: 20,
    waitForConnections: true,
    ssl: {
      ca: fs.readFileSync('./ca.pem')
    }
  }
})
```

**PostgreSQL (Cloud):**

```typescript
const db = new ObjectQL({
  driver: 'postgresql',
  url: process.env.DATABASE_URL,
  postgres: {
    max: 25,
    ssl: { rejectUnauthorized: false }
  }
})
```

## Schema Management

### registerSchema()

Register a schema with ObjectQL.

```typescript
await db.registerSchema(schema: Schema): Promise<void>
```

#### Parameters

- `schema` - Schema definition object

#### Example

```typescript
await db.registerSchema({
  objects: {
    customer: {
      label: 'Customer',
      fields: {
        name: { type: 'text', required: true },
        email: { type: 'email', unique: true },
        status: { 
          type: 'select', 
          options: ['active', 'inactive'],
          defaultValue: 'active'
        }
      }
    },
    order: {
      label: 'Order',
      fields: {
        customer: {
          type: 'master_detail',
          reference_to: 'customer'
        },
        amount: { type: 'currency', scale: 2 },
        status: {
          type: 'select',
          options: ['pending', 'paid', 'cancelled']
        }
      }
    }
  }
})
```

### getSchema()

Get registered schema.

```typescript
const schema = db.getSchema(objectName?: string): Schema | ObjectSchema
```

#### Parameters

- `objectName` - Optional. Return schema for specific object

#### Example

```typescript
// Get entire schema
const allSchema = db.getSchema()

// Get specific object schema
const customerSchema = db.getSchema('customer')
console.log(customerSchema.fields)
```

## Query Operations

### query()

Query records from an object.

```typescript
const results = await db.query<T>(
  objectName: string,
  options?: QueryOptions
): Promise<T[]>
```

#### QueryOptions

```typescript
interface QueryOptions {
  fields?: string[]           // Fields to return
  filters?: Filter[]          // WHERE conditions
  sort?: string | Sort[]      // ORDER BY
  limit?: number              // LIMIT
  skip?: number               // OFFSET
  top?: number                // Alternative to limit
}

type Filter = 
  | [string, Operator, any]           // Simple filter
  | ['and' | 'or', ...Filter[]]       // Compound filter

type Operator = 
  | '=' | '!=' | '>' | '>=' | '<' | '<=' 
  | 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte'
  | 'in' | 'notin' | 'between'
  | 'contains' | 'startswith' | 'endswith' | 'notcontains'
  | 'like' | 'not like'
  | 'is null' | 'is not null'
```

#### Examples

**Basic Query:**

```typescript
// Get all active customers
const customers = await db.query('customer', {
  filters: [['status', '=', 'active']]
})
```

**Field Selection:**

```typescript
// Select specific fields
const customers = await db.query('customer', {
  fields: ['_id', 'name', 'email'],
  filters: [['status', '=', 'active']]
})
```

**Complex Filters:**

```typescript
// Complex AND/OR conditions
const orders = await db.query('order', {
  filters: [
    'and',
    ['status', 'in', ['pending', 'paid']],
    ['amount', '>', 100],
    [
      'or',
      ['customer.city', '=', 'New York'],
      ['customer.city', '=', 'Los Angeles']
    ]
  ]
})
```

**Sorting and Pagination:**

```typescript
// Sort and paginate
const page = 1
const pageSize = 25

const customers = await db.query('customer', {
  sort: [
    { field: 'created', order: 'desc' },
    { field: 'name', order: 'asc' }
  ],
  limit: pageSize,
  skip: (page - 1) * pageSize
})
```

**Related Fields:**

```typescript
// Query with related fields
const orders = await db.query('order', {
  fields: ['_id', 'amount', 'customer.name', 'customer.email'],
  filters: [['status', '=', 'pending']]
})

// Result: [
//   { 
//     _id: '123', 
//     amount: 199.99, 
//     customer: { name: 'John Doe', email: 'john@example.com' }
//   }
// ]
```

### queryOne()

Query a single record.

```typescript
const record = await db.queryOne<T>(
  objectName: string,
  options?: QueryOptions
): Promise<T | null>
```

#### Example

```typescript
// Get customer by ID
const customer = await db.queryOne('customer', {
  filters: [['_id', '=', customerId]]
})

if (!customer) {
  throw new Error('Customer not found')
}
```

### count()

Count records matching filters.

```typescript
const total = await db.count(
  objectName: string,
  filters?: Filter[]
): Promise<number>
```

#### Example

```typescript
// Count active customers
const activeCount = await db.count('customer', [
  ['status', '=', 'active']
])

// Total count
const totalCount = await db.count('customer')
```

## Mutation Operations

### mutation()

Insert, update, or delete records.

```typescript
const result = await db.mutation(
  objectName: string,
  options: MutationOptions
): Promise<MutationResult>
```

#### MutationOptions

```typescript
interface MutationOptions {
  action: 'insert' | 'update' | 'delete'
  data?: Record<string, any> | Record<string, any>[]
  filters?: Filter[]
}

interface MutationResult {
  success: boolean
  ids?: string[]        // Inserted/updated record IDs
  count?: number        // Number of affected records
  errors?: Error[]
}
```

#### Insert Examples

**Single Insert:**

```typescript
const result = await db.mutation('customer', {
  action: 'insert',
  data: {
    name: 'Acme Corporation',
    email: 'contact@acme.com',
    status: 'active'
  }
})

console.log(result.ids[0])  // ID of created record
```

**Batch Insert:**

```typescript
const result = await db.mutation('product', {
  action: 'insert',
  data: [
    { name: 'Product A', price: 29.99 },
    { name: 'Product B', price: 49.99 },
    { name: 'Product C', price: 79.99 }
  ]
})

console.log(result.count)  // 3
console.log(result.ids)    // ['id1', 'id2', 'id3']
```

#### Update Examples

**Update by ID:**

```typescript
await db.mutation('customer', {
  action: 'update',
  filters: [['_id', '=', customerId]],
  data: {
    status: 'inactive',
    notes: 'Account closed'
  }
})
```

**Batch Update:**

```typescript
// Deactivate all customers from specific city
await db.mutation('customer', {
  action: 'update',
  filters: [['city', '=', 'Old City']],
  data: {
    status: 'inactive'
  }
})
```

#### Delete Examples

**Delete by ID:**

```typescript
await db.mutation('customer', {
  action: 'delete',
  filters: [['_id', '=', customerId]]
})
```

**Conditional Delete:**

```typescript
// Delete all archived orders older than 1 year
const oneYearAgo = new Date()
oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1)

await db.mutation('order', {
  action: 'delete',
  filters: [
    ['status', '=', 'archived'],
    ['created', '<', oneYearAgo.toISOString()]
  ]
})
```

## Aggregation Operations

### aggregate()

Perform aggregation queries.

```typescript
const results = await db.aggregate(
  objectName: string,
  options: AggregateOptions
): Promise<AggregateResult[]>
```

#### AggregateOptions

```typescript
interface AggregateOptions {
  group_by: string[]              // GROUP BY fields
  fields?: AggregateField[]       // Aggregate calculations
  filters?: Filter[]              // WHERE clause
  having?: Filter[]               // HAVING clause
  sort?: string | Sort[]          // ORDER BY
  limit?: number                  // LIMIT
}

interface AggregateField {
  field: string
  function: 'count' | 'sum' | 'avg' | 'min' | 'max' | 'count_distinct'
  alias?: string
}
```

#### Examples

**Simple Aggregation:**

```typescript
// Count customers by status
const statusCounts = await db.aggregate('customer', {
  group_by: ['status'],
  fields: [
    { field: '_id', function: 'count', alias: 'total' }
  ]
})

// Result: [
//   { status: 'active', total: 150 },
//   { status: 'inactive', total: 23 }
// ]
```

**Sales Report:**

```typescript
// Monthly sales summary
const monthlySales = await db.aggregate('order', {
  filters: [
    ['status', '=', 'paid'],
    ['created', '>=', '2024-01-01']
  ],
  group_by: ['YEAR(created)', 'MONTH(created)'],
  fields: [
    { field: 'amount', function: 'sum', alias: 'revenue' },
    { field: '_id', function: 'count', alias: 'order_count' },
    { field: 'amount', function: 'avg', alias: 'avg_order' },
    { field: 'customer_id', function: 'count_distinct', alias: 'unique_customers' }
  ],
  having: [
    ['revenue', '>', 10000]
  ],
  sort: 'YEAR(created) desc, MONTH(created) desc'
})
```

**Customer Spending:**

```typescript
// Top spending customers
const topCustomers = await db.aggregate('order', {
  group_by: ['customer_id'],
  fields: [
    { field: 'amount', function: 'sum', alias: 'total_spent' },
    { field: '_id', function: 'count', alias: 'order_count' }
  ],
  having: [
    ['total_spent', '>', 1000]
  ],
  sort: 'total_spent desc',
  limit: 10
})
```

## Virtual City

### virtualCity()

Create a Virtual City instance for multi-tenant data isolation.

```typescript
const tenantDb = db.virtualCity(spaceId: string): ObjectQL
```

#### Parameters

- `spaceId` - Unique identifier for the tenant/space

#### Example

```typescript
// Create tenant-specific instances
const tenant1Db = db.virtualCity('tenant_001')
const tenant2Db = db.virtualCity('tenant_002')

// Each tenant sees only their data
await tenant1Db.mutation('customer', {
  action: 'insert',
  data: { name: 'Tenant 1 Customer' }
})

await tenant2Db.mutation('customer', {
  action: 'insert',
  data: { name: 'Tenant 2 Customer' }
})

// Tenant 1 query
const tenant1Customers = await tenant1Db.query('customer', {})
// Returns: [{ name: 'Tenant 1 Customer', space: 'tenant_001' }]

// Tenant 2 query
const tenant2Customers = await tenant2Db.query('customer', {})
// Returns: [{ name: 'Tenant 2 Customer', space: 'tenant_002' }]
```

**SaaS Application:**

```typescript
// Express.js middleware
app.use((req, res, next) => {
  const tenantId = req.headers['x-tenant-id']
  req.db = db.virtualCity(tenantId)
  next()
})

// Route handlers use tenant-specific db
app.get('/api/customers', async (req, res) => {
  const customers = await req.db.query('customer', {})
  res.json(customers)
})
```

## Transaction Support

### transaction()

Execute multiple operations in a transaction.

```typescript
await db.transaction(async (trx) => {
  // All operations use the transaction
})
```

#### Example

```typescript
// Transfer order between customers
await db.transaction(async (trx) => {
  // Update order
  await trx.mutation('order', {
    action: 'update',
    filters: [['_id', '=', orderId]],
    data: { customer_id: newCustomerId }
  })
  
  // Log the transfer
  await trx.mutation('audit_log', {
    action: 'insert',
    data: {
      action: 'order_transfer',
      order_id: orderId,
      old_customer: oldCustomerId,
      new_customer: newCustomerId
    }
  })
})
```

## Utility Methods

### close()

Close database connection and cleanup resources.

```typescript
await db.close(): Promise<void>
```

#### Example

```typescript
// Graceful shutdown
process.on('SIGTERM', async () => {
  await db.close()
  process.exit(0)
})
```

### getPoolStats()

Get connection pool statistics.

```typescript
const stats = await db.getPoolStats(): Promise<PoolStats>

interface PoolStats {
  total: number      // Total connections
  idle: number       // Idle connections
  active: number     // Active connections
  waiting: number    // Waiting requests
}
```

#### Example

```typescript
// Monitor connection pool
setInterval(async () => {
  const stats = await db.getPoolStats()
  console.log('DB Pool:', stats)
  
  if (stats.waiting > 10) {
    console.warn('High connection wait queue!')
  }
}, 60000)
```

## Error Handling

ObjectQL throws specific error types for different scenarios:

```typescript
import { 
  ValidationError, 
  NotFoundError, 
  DuplicateError,
  DatabaseError 
} from '@objectql/core'

try {
  await db.mutation('customer', {
    action: 'insert',
    data: { email: 'duplicate@example.com' }
  })
} catch (error) {
  if (error instanceof ValidationError) {
    // Handle validation errors
    console.error('Validation failed:', error.fields)
  } else if (error instanceof DuplicateError) {
    // Handle duplicate key errors
    console.error('Duplicate:', error.field)
  } else if (error instanceof DatabaseError) {
    // Handle database errors
    console.error('Database error:', error.message)
  }
}
```

## TypeScript Support

ObjectQL provides full TypeScript support with type inference:

```typescript
import { ObjectQL, Schema } from '@objectql/core'

// Define schema type
interface Customer {
  _id: string
  name: string
  email: string
  status: 'active' | 'inactive'
  created: Date
}

// Type-safe queries
const customers = await db.query<Customer>('customer', {
  filters: [['status', '=', 'active']]
})

// TypeScript knows the shape
customers.forEach(customer => {
  console.log(customer.name)  // ✓ Type-safe
  console.log(customer.foo)   // ✗ Compile error
})
```

## Next Steps

- Review [Protocol Spec](./protocol-spec) for detailed query syntax
- Explore [Core Features](./core-features) for advanced optimizations
- Check [Core Concepts](./core-concepts) for foundational knowledge
