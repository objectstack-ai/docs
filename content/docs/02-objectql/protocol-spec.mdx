---
title: Protocol Specification
description: Overview and reference guide for ObjectQL's protocol specification
---

# Protocol Specification

ObjectQL uses a protocol-driven architecture with a comprehensive specification covering data modeling, querying, aggregation, and mutation operations. This specification ensures consistency across implementations and provides a clear contract for developers.

## Core Components

The ObjectQL protocol specification is divided into four main components:

### [Schema Definition](/docs/02-objectql/schema-definition)

Define your data model with:
- **Object definitions** - Database tables with metadata
- **Field types** - Text, numeric, date/time, boolean, select, relationship, and special fields
- **Field constraints** - Validation, indexes, and dependencies

### [Query DSL](/docs/02-objectql/query-dsl)

Query your data with:
- **Filters** - Comparison, string, list, null, and compound operators
- **Sorting** - Single or multiple field ordering
- **Pagination** - Limit and skip for efficient data retrieval
- **Field selection** - Choose specific fields including related data

### [Aggregation Operations](/docs/02-objectql/aggregation)

Analyze your data with:
- **GroupBy** - Group records by one or more fields
- **Aggregate functions** - Count, sum, average, min, max, distinct count
- **Having clause** - Filter aggregated results
- **Pre and post-aggregation filters** - WHERE and HAVING clauses

### [Mutation Operations](/docs/02-objectql/mutation)

Modify your data with:
- **Insert** - Create new records
- **Update** - Modify existing records
- **Delete** - Remove records
- **Batch operations** - Efficient bulk operations

## Protocol Principles

The ObjectQL protocol follows these key principles:

1. **Declarative** - Describe what you want, not how to get it
2. **Type-safe** - Strong typing for reliability
3. **Composable** - Build complex operations from simple building blocks
4. **Efficient** - Optimized for performance at scale
5. **Consistent** - Uniform patterns across all operations

## Quick Start

Here's a complete example using all protocol components:

```typescript
// 1. Define schema
const schema = {
  objects: {
    customer: {
      label: 'Customer',
      fields: {
        name: { type: 'text', required: true },
        email: { type: 'email', unique: true },
        status: { type: 'select', options: ['active', 'inactive'] }
      }
    }
  }
}

// 2. Insert data
await db.mutation('customer', {
  action: 'insert',
  data: { name: 'Acme Corp', email: 'contact@acme.com', status: 'active' }
})

// 3. Query data
const customers = await db.query('customer', {
  filters: [['status', '=', 'active']],
  sort: 'name asc',
  limit: 10
})

// 4. Aggregate data
const stats = await db.aggregate('customer', {
  group_by: ['status'],
  fields: [{ field: '_id', function: 'count', alias: 'total' }]
})
```

## Next Steps

- Start with [Schema Definition](/docs/02-objectql/schema-definition) to model your data
- Learn [Query DSL](/docs/02-objectql/query-dsl) to retrieve data
- Master [Aggregation](/docs/02-objectql/aggregation) for data analysis
- Understand [Mutation Operations](/docs/02-objectql/mutation) for data modification
- Explore [Core Features](/docs/02-objectql/core-features) for advanced capabilities
- Check [Core Concepts](/docs/02-objectql/core-concepts) for foundational knowledge
