---
title: 权限与治理
description: 三层安全模型。RBAC、字段级安全和记录级共享规则。
sidebar_position: 3
slug: /objectos/permission-governance
---

# 权限与治理

在 ObjectStack 中，安全性不是在 API 控制器或 UI 逻辑中实现的。它是**由内核注入**的。

当开发人员编写查询 `db.find('contract')` 时，他们不需要担心*谁*在运行它。ObjectOS 内核自动截获请求、分析用户会话，并重写查询以确保他们只能看到允许他们看到的内容。

我们称之为**三层安全模型**。



## 第 1 层：对象级安全 (RBAC)
**"我能进入房间吗？"**

这是基础的基于角色的访问控制。它确定用户是否可以对对象类型执行通用 CRUD 操作。

### 简介定义
权限捆绑到**简介**或**权限集**中。

```yaml
# permissions/profiles/sales_rep.profile.yml
name: sales_rep
label: Sales Representative
license: standard

permissions:
  - object: lead
    allow_create: true
    allow_read: true
    allow_edit: true
    allow_delete: false  # 代表无法删除潜在客户
    allow_view_all: false # 只能看到自己的（参见第 3 层）
    allow_modify_all: false

  - object: product
    allow_read: true
    allow_create: false  # 只读

```

* **`allow_view_all`：** "上帝模式"标志。如果为真，则忽略共享规则（第 3 层）。
* **`allow_modify_all`：** 无论所有权如何，都可以编辑/删除任何记录。

## 第 2 层：字段级安全 (FLS)

**"我能看到这个文件夹的内容吗？"**

即使您有权访问 `Employee` 对象，您也可能无权查看 `Salary` 列。

### FLS 协议

FLS 与对象权限一起定义。它控制可见性（`read`）和可变性（`edit`）。

```yaml
# permissions/profiles/sales_rep.profile.yml (续)
field_permissions:
  # 对象：lead
  lead.revenue:
    read: true
    edit: true
  
  # 对象：employee
  employee.salary:
    read: false # 编译器从 SELECT 中物理移除此列
    edit: false

```

### 编译器行为

如果用户尝试查询禁止的字段：

1. **严格模式：** API 抛出 `403 Forbidden` 错误。
2. **宽松模式（默认）：** 该字段从返回有效负载中静默删除（返回 `undefined`），确保 UI 不会崩溃，但数据仍然安全。

## 第 3 层：记录级安全（共享）

**"我能打开哪些特定文件？"**

这是最复杂和最强大的层。它回答："*为什么 Alice 能看到 Deal A 但不能看到 Deal B？*"

ObjectOS 根据四种机制（按顺序评估）确定记录可见性：

### 1. 组织范围默认值 (OWD)

对象的基线策略。

* **公共读/写：** 每个人都可以查看和编辑所有内容。
* **公开只读：** 每个人都可以查看，但只有所有者可以编辑。
* **私密：** 用户只能看到他们拥有的记录（或被授予访问权限的记录）。

### 2. 所有权

每条记录都有一个 `owner` 字段（用户 ID）。

* **所有者**始终对其记录拥有完全访问权限（读/编辑/删除/转移）。

### 3. 角色层次结构

ObjectOS 支持分层树（例如，CEO > VP > Manager > Rep）。

* **规则：** 经理继承对下属拥有的数据的访问权限。
* 如果 Rep 拥有 Deal，他们的 Manager 可以自动看到它。

### 4. 共享规则（基于条件）

层次结构的例外。用于横向共享数据或基于逻辑共享数据。

```yaml
# permissions/sharing/deal_high_value.sharing.yml
name: share_high_value_deals
object: deal
type: criteria
condition: "amount > 1000000" # 如果交易超过 100 万美元

access_level: read_only

shared_with: 
  role: "vp_finance" # 与财务副总裁共享，即使他们在不同的分支

```

## 查询注入机制

这是如何有效工作的？ObjectOS **不**在内存中过滤数据（这会很慢）。它使用**谓词注入**。

**场景：**
用户"Alice"（角色：Rep，ID：`u1`）查询 `SELECT * FROM lead`。
`lead` 对象是**私密**的。

**步骤 1：内核分析**

* Alice 在 `lead` 上有 `allow_read: true`。（第 1 层：通过）
* Alice 请求 `salary`，但 `FLS: false`。字段已删除。（第 2 层：已调整）
* Alice 在"西方销售"角色中。

**步骤 2：谓词生成**
安全引擎生成 SQL `WHERE` 子句：

```sql
(
  -- 所有权
  t1.owner = 'u1' 
  OR 
  -- 层次结构（Alice 的下属）
  t1.owner IN ('u2', 'u3')
  OR
  -- 共享规则（与 Alice 的小组共享）
  t1.id IN (SELECT record_id FROM objectos_shares WHERE user_or_group_id = 'group_western')
)

```

**步骤 3：最终执行**
修改后的 AST 被发送到数据库驱动程序。

## 共享计算

为了性能，复杂的共享规则（如组成员关系和共享条件）通常被预计算为**共享表** (`objectos_shares`)。

* **异步计算：** 当用户角色改变或 Deal 金额改变时，后台作业重新计算 `objectos_shares` 条目。
* **即时读取：** 查询只需加入共享表，保持读取延迟低。

## 摘要：安全矩阵

| 层 | 控制 | 通过以下配置 | 执行 |
| --- | --- | --- | --- |
| **对象 (RBAC)** | CRUD 操作 | 简介 (YAML) | API 网关 |
| **字段 (FLS)** | 列可见性 | 简介 (YAML) | 查询编译器 (AST) |
| **记录 (共享)** | 行可见性 | OWD / 规则 / 层次结构 | SQL 注入 (WHERE) |

:::tip 开发人员注意
编写服务器端代码（触发器/API）时，您通常使用**用户会话**。安全规则会自动应用。如果需要访问所有数据（例如，用于后台计算），请明确使用 `session.sudo()` 或 `sudo: true` 来绕过第 3 层检查。
:::
