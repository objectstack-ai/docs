---
title: 分析协议
description: 使用 ObjectQL 协议定义聚合、数据透视表和 BI 数据源。
---

# 分析协议

在传统架构中，生成报告通常需要将数据导出到数据仓库或编写复杂的、不可移植的 SQL 查询。

ObjectQL 弥合了事务性（OLTP）和分析性（OLAP）工作负载之间的差距。它提供**声明式分析协议**，允许您直接从操作数据库请求分组、汇总和重塑的数据，或透明地将这些请求路由到分析副本。

## 1. 聚合 AST

就像您查询记录一样，您也可以查询**聚合**。聚合协议旨在成为 SQL `GROUP BY` 或 MongoDB 聚合管道的与数据库无关的抽象。

### 协议结构

聚合请求由三个核心组件组成：**维度**（分组）、**度量**（值）和**过滤**（作用域）。

```typescript
// @objectql/types
interface AggregateRequest {
  object: string;           // Target Object (e.g., 'invoice')
  filters?: FilterNode;     // Scope (e.g., 'year = 2024')
  groupBy: string[];        // Dimensions (e.g., ['sales_rep', 'status'])
  measures: Record<string, AggregateDef>; // Calculations
}

interface AggregateDef {
  field: string;
  method: 'sum' | 'avg' | 'min' | 'max' | 'count' | 'count_distinct';
}

```

### 示例：销售绩效

> *"按销售代表显示已关闭交易的总销售额和平均交易规模。"*

**协议（JSON）：**

```json
{
  "object": "deal",
  "filters": [["stage", "=", "closed_won"]],
  "groupBy": ["owner"],
  "measures": {
    "total_revenue": { "field": "amount", "method": "sum" },
    "avg_deal_size": { "field": "amount", "method": "avg" },
    "deal_count": { "field": "_id", "method": "count" }
  }
}

```

**编译（SQL）：**

```sql
SELECT 
  t1.owner, 
  SUM(t1.amount) as total_revenue, 
  AVG(t1.amount) as avg_deal_size,
  COUNT(t1._id) as deal_count
FROM deals t1
WHERE t1.stage = 'closed_won'
GROUP BY t1.owner

```

## 2. 日期直方图（时间序列分析）

企业报告在很大程度上依赖于基于时间的分组（例如，"每月销售额"）。ObjectQL 标准化了日期截断，以确保在数据库中的行为一致。

### 协议语法

在 `groupBy` 数组中使用特殊逻辑函数 `date_trunc(field, interval)`。

```json
{
  "object": "log_entry",
  "groupBy": ["date_trunc('created_at', 'month')"],
  "measures": {
    "error_count": { "field": "_id", "method": "count" }
  }
}

```

* **Postgres 驱动程序：** 编译为 `DATE_TRUNC('month', created_at)`
* **MySQL 驱动程序：** 编译为 `DATE_FORMAT(created_at, '%Y-%m-01')`
* **Mongo 驱动程序：** 编译为 `$dateToString`（带格式）。

## 3. 数据透视协议（交叉制表）

数据透视表将行转换为列。虽然大多数 ORM 将此留给前端，但 ObjectQL 在协议中定义了**数据透视结构**，以启用服务器端优化（以及与 Excel 类似的 UI 组件的兼容性）。

### 协议结构

```typescript
interface PivotRequest {
  object: string;
  rows: string[];    // The Y-Axis (e.g., Region)
  columns: string[]; // The X-Axis (e.g., Year)
  values: AggregateDef[]; // The Cell Data
}

```

### 示例：按地区与年份的销售额

```json
{
  "type": "pivot",
  "object": "sales_order",
  "rows": ["region"],
  "columns": ["fiscal_year"],
  "values": [{ "field": "amount", "method": "sum" }]
}

```

### 响应格式

引擎返回一个标准化结构，可直接用于呈现网格组件：

```json
{
  "metadata": { "columns": ["2023", "2024", "2025"] },
  "data": [
    { "region": "North", "2023": 1000, "2024": 1500, "2025": 2000 },
    { "region": "South", "2023": 800,  "2024": 900,  "2025": 1100 }
  ]
}

```

## 4. BI 数据源（无头 BI）

ObjectQL 启用了**"无头 BI"**架构。您可以在 ObjectQL **分析立方体**中定义指标，而不是在 Tableau 或 PowerBI 中定义指标（它们被锁定）。

### 定义立方体（YAML）

立方体是专门为分析设计的虚拟视图。

```yaml
# src/analytics/sales_cube.yml
name: sales_performance
label: Sales Performance Cube
base_object: deal
dimensions:
  - name: region
    field: owner.region
  - name: month
    expression: "date_trunc('created_at', 'month')"
measures:
  - name: revenue
    field: amount
    method: sum
  - name: win_rate
    expression: "count(case when stage='won' then 1 end) / count(*)"

```

### 使用

外部 BI 工具可以通过 ObjectQL 分析 API 使用此立方体。

* **API：** `POST /api/analytics/cube/sales_performance/query`
* **好处：** 如果您在 YAML 中更改"收入"的定义，每个报告（仪表板、PDF、Excel 导出）都会立即更新。

## 5. 性能和物化

实时对数百万行运行聚合是资源密集型的。ObjectQL 支持**透明物化**。

### `materialized` 标志

```yaml
# src/analytics/sales_cube.yml
name: sales_performance
materialized: true
refresh_interval: "1h"

```

* **行为：** ObjectOS 内核自动创建一个**物化视图**（在 Postgres 中）或单独的汇总集合（在 Mongo 中）。
* **路由：** 当客户端查询此立方体时，ObjectQL 编译器重写查询以命中预计算的视图，而不是原始表。
* **延迟：** 查询变成即时（O(1)），代价是数据新鲜度（例如，1 小时延迟）。

:::tip 架构师说明
对于超过 100M 行的数据集，ObjectQL 驱动程序可以配置为将分析查询卸载到专用的 OLAP 引擎（如 ClickHouse 或 Snowflake），同时保持协议相同。这允许您在不重写应用程序逻辑的情况下扩展基础结构。
:::
