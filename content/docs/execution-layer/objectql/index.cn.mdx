---
title: ObjectQL 概览
description: 数据协议简介。了解数据库编译器架构和抽象语法树（AST）。
---

# ObjectQL 数据协议

**ObjectQL** 是一个与数据库无关的协议，用于定义、查询和操作企业数据。

与 ORM（一个代码库）或 GraphQL（一个 API 规范）不同，ObjectQL 充当**数据库编译器**的角色。它在物理存储引擎上创建了一个标准化的抽象层，使应用程序能够用 JSON/YAML 定义业务意图，并在 PostgreSQL、SQLite、MongoDB 或 Oracle 上高效执行，无需代码更改。

## 架构：数据库编译器

ObjectQL 的核心创新是将数据库交互视为一个编译过程，而不是字符串连接过程。



管道由四个阶段组成：

1.  **模式定义（输入）：** 开发者使用 **[对象协议](./schema-definition)** (YAML) 定义数据形状。
2.  **请求解析（AST）：** 在运行时，查询以 JSON 形式接收并解析为严格的 **[抽象语法树](./ast-structure)**。
3.  **语义分析（中间件）：** 内核注入安全谓词（RBAC）、验证类型并应用逻辑钩子。
4.  **编译（输出）：** **驱动程序** 将优化后的 AST 转换为目标数据库的原生方言（例如 PL/SQL）。

## 核心概念

要理解后续的规范，您必须熟悉这三个概念：

### 1. 单一信息源
在 ObjectStack 中，数据库模式（`CREATE TABLE`）**不是**信息源。**ObjectQL 模式**才是。
* ObjectQL 引擎负责执行 DDL 迁移，使物理数据库与 YAML 定义保持同步。
* 这确保"业务逻辑"（例如，该字段是具有 2 位小数的货币）在各个环境中得到保留。

### 2. 通用 AST
ObjectQL 定义了一个基于 JSON 的 **Wire Protocol**。这作为中间表示（IR）。
* **意图：** `{ "op": "find", "from": "users", "where": ["age", ">", 18] }`
* **实现：** 解耦。发送者不需要知道接收者是使用 Postgres 还是 CSV 文件。

### 3. 智能类型
ObjectQL 支持超越标准 SQL 的 **企业数据类型**。
* **主-从关系：** 自动处理父子级联。
* **汇总/汇总：** 声明式聚合（例如，"总订单数"）。
* **公式：** 在读取时计算的虚拟列。

## 为什么不只用 SQL？

SQL 很强大，但它是一种**语言**，而不是**协议**。

| 特性 | 原始 SQL | ObjectQL 协议 |
| :--- | :--- | :--- |
| **结构** | 非结构化字符串 | 结构化 JSON AST |
| **安全性** | 易受注入攻击（如果不小心） | 数学上防止注入 |
| **可移植性** | 特定于供应商（PL/SQL vs T-SQL） | 100% 可移植 |
| **治理** | 难以解析/拦截 | 易于注入权限（AST 中间件） |
| **上下文** | 无状态 | 了解用户会话和租户 |

## 规范路线图

本文档部分定义了 ObjectQL 的严格协议：

* **[模式定义](./schema-definition)**：如何在 YAML 中定义对象、字段和关系。
* **[高级类型](./advanced-types)**：货币、查询和公式的规范。
* **[AST 结构](./ast-structure)**：查询的 JSON Wire 格式。
* **[分析协议](./analytics-protocol)**：定义聚合、数据透视表和 BI 立方体。
* **[事务模型](./transaction-model)**：原子性和跨对象变更的规则。
* **[安全注入](./security-injection)**：编译器如何强制执行 RBAC 和 FLS。

:::info 实现说明
虽然 `steedos-server` 是参考实现（Node.js），但 ObjectQL 规范是与语言无关的。符合规范的驱动程序可以用 Go、Rust 或 Java 编写。
:::
