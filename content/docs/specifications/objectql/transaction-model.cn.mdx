---
title: 事务模型
description: 通过跨对象事务、原子操作和乐观锁定确保数据完整性。
sidebar_position: 5
slug: /objectql/transaction-model
---

# 事务模型和原子性

在企业应用程序中，数据完整性是不可商量的。一个经典示例是保存一个**订单**及其**行项目**。您不能创建没有项目的订单，也不能在订单保存失败的情况下扣除库存。

ObjectQL 提供**声明式事务协议**来处理这些场景，而无需编写复杂的命令式代码。

## 1. 原子变更协议

标准 REST API 通常会强制您进行多个请求（`POST /orders`，然后循环 `POST /items`）。如果网络在中途失败，您会有"僵尸数据"。

ObjectQL 通过**原子变更数据包**解决这个问题。您可以将多个操作捆绑到一个请求中。如果*任何*操作失败，整个事务都会回滚。

### 嵌套变更（父子）
最常见的模式是同时创建主记录及其详细信息。

**协议有效负载（JSON）：**
```json
{
  "operation": "create",
  "object": "order",
  "data": {
    "customer": "cust_001",
    "date": "2024-03-20",
    "status": "draft",
    // Nested writes are detected automatically
    "lines": [
      {
        "product": "prod_A",
        "quantity": 5,
        "price": 100
      },
      {
        "product": "prod_B",
        "quantity": 2,
        "price": 50
      }
    ]
  }
}

```

* **行为：** ObjectQL 引擎检测 `lines` 关系。它打开数据库事务，插入订单，获取新的 `_id`，将其注入到行中，插入行，然后提交。

### 批量变更（混合对象）

有时您需要在一次操作中更新无关的对象（例如，"批准发票"AND"扣除预算"）。

**协议有效负载（JSON）：**

```json
{
  "operation": "transaction",
  "steps": [
    {
      "operation": "update",
      "object": "invoice",
      "id": "inv_123",
      "data": { "status": "approved" }
    },
    {
      "operation": "update",
      "object": "budget",
      "id": "bdg_999",
      "data": { "amount_remaining": { "$inc": -5000 } }
    }
  ]
}

```

## 2. 乐观锁定（并发控制）

在多用户环境中（例如，两个销售代表编辑同一笔交易），"最后写入获胜"是危险的。它会导致数据丢失。

ObjectQL 默认通过 `_version` 字段强制执行**乐观锁定**。

### 机制

1. **读取：** 当您获取记录时，ObjectQL 返回 `_version` 号（例如 `v1`）。
2. **写入：** 当您更新时，您**必须**发回您读取的 `_version`。
3. **检查：** 数据库执行：`UPDATE ... WHERE id = '...' AND _version = 1`。
4. **结果：**
* 如果受影响的行 = 1：成功。`_version` 增加到 2。
* 如果受影响的行 = 0：**冲突错误**。其他人已将其更新为 `v2`。



### 协议示例

**请求：**

```json
{
  "operation": "update",
  "object": "deal",
  "id": "deal_123",
  "data": { "amount": 20000 },
  "_version": 5  // I believe I am editing version 5
}

```

**响应（错误）：**

```json
{
  "error": {
    "code": "VERSION_CONFLICT",
    "message": "Record has been modified by another user.",
    "current_version": 6
  }
}

```

:::tip UI 处理
ObjectUI 自动处理此问题。如果它收到 `VERSION_CONFLICT`，它会提示用户"刷新并重新应用"。
:::

## 3. 服务器端事务钩子

有时，逻辑太复杂而无法在客户端处理。您需要在服务器上定义事务边界。

您可以在 `*.trigger.ts` 文件中定义**事务钩子**。这些钩子在数据库事务作用域*内*运行。

```typescript
// src/triggers/order.trigger.ts
import { Trigger } from '@objectql/types';

export const afterOrderApprove: Trigger = {
  on: 'update',
  object: 'order',
  when: (newDoc, oldDoc) => newDoc.status === 'approved' && oldDoc.status !== 'approved',
  
  // This function receives a 'session' which is bound to the DB transaction
  handler: async ({ id, session, broker }) => {
    
    // 1. Create Shipment (Must succeed)
    await broker.call('data.create', {
      object: 'shipment',
      data: { order_id: id }
    }, { session });

    // 2. Notify Warehouse (Side effect, does not block transaction)
    await broker.emit('warehouse.notify', { order_id: id });
    
    // If Step 1 throws an error, the Order update is ALSO rolled back.
  }
}

```

## 4. 隔离级别

ObjectQL 通常默认为关系数据库的**读已提交**隔离级别。

* **脏读：** 防止。您永远看不到来自其他事务的未提交数据。
* **不可重复读：** 允许。
* **幻读：** 允许。

对于需要严格序列化访问的场景（例如，生成顺序发票号码），使用**原子增量**操作符或专用序列对象，而不是锁定整个表。

```json
// Atomic Increment Protocol
{
  "operation": "update",
  "object": "counter",
  "id": "invoice_seq",
  "data": { "seq": { "$inc": 1 } }
}

```

## 总结

| 特性 | 描述 | 好处 |
| --- | --- | --- |
| **嵌套变更** | 在一个 JSON 中保存父级 + 子级。 | 防止孤立记录。 |
| **事务数据包** | 捆绑混合操作。 | 确保跨模块一致性。 |
| **乐观锁定** | `_version` 检查。 | 防止多用户应用程序中的丢失更新。 |
| **钩子** | 事务中的服务器端逻辑。 | 保证业务规则完整性。 |
