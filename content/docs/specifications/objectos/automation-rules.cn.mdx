---
title: 自动化规则
description: 服务器端逻辑协议。数据库触发器、计划作业和无代码自动化流。
---

# 自动化规则

虽然工作流引导记录经历生命周期，但**自动化规则**处理数据变更的即时逻辑和副作用。

ObjectOS 将自动化分为三类：
1.  **触发器（代码）：** 用于数据完整性的高性能、同步 TypeScript 钩子。
2.  **流（低代码）：** 声明性、异步事件链（IFTTT 风格）。
3.  **计划作业：** 基于时间的执行（CRON）。

## 1. 数据库触发器（同步逻辑）

触发器是系统的"反射"。它们在数据库操作发生**之前**或**之后**截获它们。它们在与变更相同的数据库事务中执行。

### 触发器定义

触发器在对象定义旁的 TypeScript 文件中定义。

```typescript
// triggers/order.trigger.ts
import { Trigger } from '@objectos/types';

export const validateDiscount: Trigger = {
  name: 'validate_order_discount',
  object: 'order',
  on: ['create', 'update'],
  when: 'before', // 在写入数据库前运行

  handler: async ({ doc, previousDoc, session, broker }) => {
    // 1. 逻辑：折扣不能超过 20%，除非获得授权
    if (doc.discount > 0.20 && !session.hasRole('manager')) {
      throw new Error("Discounts > 20% require Manager approval.");
    }

    // 2. 逻辑：自动计算最终价格
    doc.final_price = doc.list_price * (1 - doc.discount);
  }
}

```

### 关键能力

* **验证：** 抛出错误将中止整个事务。
* **计算：** 直接修改 `doc` 会更新正在保存的数据。
* **快照访问：** 您可以访问 `doc`（新状态）和 `previousDoc`（旧状态）来检测更改（例如，`if (doc.status !== previousDoc.status)`）。

## 2. 自动化流（声明性逻辑）

对于不需要硬编码的逻辑，ObjectOS 支持**自动化流**。这些在 YAML 中定义（或通过可视化生成器构建），并在事务提交**之后****异步**运行。

### 流协议

```yaml
# automations/notify_high_value_deal.yaml
name: notify_high_value_deal
label: Notify VP on Big Deals
trigger:
  type: data.changed
  object: deal
  condition: "doc.amount > 1000000 && doc.stage == 'closed_won'"

actions:
  - type: notification.send
    params:
      recipient: "role:vp_sales"
      subject: "Big Win: ${doc.name}"
      message: "Deal closed for ${formatCurrency(doc.amount)}!"

  - type: record.create
    params:
      object: "audit_log"
      data:
        event: "big_deal_alert"
        deal_id: "${doc._id}"

```

### 流组件

* **触发器：** 什么启动流？（`data.changed`、`user.login`、`webhook.received`）。
* **条件：** 必须为真的逻辑表达式（表达式语言）。
* **操作：** 任务的顺序列表（发送电子邮件、调用 API、创建记录）。

## 3. 计划作业（CRON）

企业系统需要在没人注意时做事情。ObjectOS 包括一个分布式**作业调度程序**。

### 协议定义

```yaml
# jobs/monthly_invoicing.job.yml
name: generate_monthly_invoices
cron: "0 0 1 * *" # 每月 1 日午夜运行
timeout: 3600 # 最多 1 小时
retries: 3

task:
  action: "finance.batch_generate_invoices"
  params:
    period: "last_month"

```

* **分布式：** 在集群中，OS 确保作业在**仅一个**节点上运行（通过 Redis 锁）。
* **弹性：** 失败的作业根据策略自动重试。

## 4. 服务器端脚本 API

无论是编写触发器还是自定义操作，您都通过标准**代理 API** 与 ObjectOS 内核交互。这确保您的代码是安全的、版本升级兼容的。

### 代理对象

`broker` 是您访问操作系统其余部分的网关。

```typescript
// 在触发器或服务内部
async function handler({ broker, session }) {
  
  // 1. 数据访问（尊重权限）
  const user = await broker.call('data.find', { 
    object: 'user', 
    id: 'u1' 
  }, { session });

  // 2. 跨服务调用
  await broker.call('mail.send', { ... });

  // 3. 发出自定义事件
  broker.emit('custom.event', { foo: 'bar' });
}

```

### "Sudo"模式

有时您需要绕过权限（例如，系统后台作业）。

```typescript
// 创建系统会话（超级管理员）
const sudoSession = session.sudo();

await broker.call('data.update', { ... }, { session: sudoSession });

```

## 5. 比较：触发器 vs. 流 vs. 工作流

| 特征 | 数据库触发器 | 自动化流 | 工作流 (BPM) |
| --- | --- | --- | --- |
| **协议** | TypeScript | YAML / JSON | YAML / BPMN |
| **时间** | 同步（阻塞） | 异步（后台） | 长期运行（天/周） |
| **事务性** | 是（可回滚） | 否（已提交） | 否 |
| **用例** | 数据完整性、计算 | 通知、同步 | 批准、生命周期 |
| **复杂性** | 高（代码） | 低（配置） | 中等（状态机） |

:::tip 最佳实践
始终为数据完整性选择**触发器**（例如，"价格不能为负"）。
始终为人工流程选择**工作流**（例如，"经理必须批准"）。
为介于两者之间的所有内容使用**流**（例如，"更新时发送电子邮件"）。
:::
