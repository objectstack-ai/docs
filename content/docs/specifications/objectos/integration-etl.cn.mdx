---
title: 集成与 ETL
description: 连接性协议。数据导入/导出、虚拟对象（外部数据源）和 API 映射标准。
---

# 集成与 ETL

没有企业应用是孤立的。它必须从供应商那里摄入 CSV、将订单同步到 SAP、以及从 LinkedIn 提取潜在客户数据。

ObjectOS 提供了统一的**集成协议**来处理这些场景。您不必编写自定义 Python 脚本或维护脆弱的中间件，只需在标准 YAML 中定义**数据映射**和**连接器**。

## 1. 导入/导出协议（ETL）

ObjectOS 包括为批量操作而设计的内置 ETL（提取、转换、加载）引擎。



### 映射模板
最终用户讨厌映射列（"'First Name' 映射到 `fname` 还是 `first_name`？"）。您可以预定义**映射模板**。

```yaml
# integration/mappings/lead_import_linkedin.map.yml
name: linkedin_lead_import
target_object: lead
source_format: csv

field_mapping:
  - source: "Profile URL"
    target: "linkedin_url"
    
  - source: "Full Name"
    target: ["first_name", "last_name"]
    transform: "split_name" # 内置助手
    
  - source: "Company"
    target: "company_id"
    transform: "lookup" # 将字符串解析为外键 ID
    params:
      object: "account"
      field: "name"
      auto_create: true # 如果找不到，创建 Account

```

### Upsert 逻辑

重复数据是敌人。ETL 协议支持声明式去重。

```yaml
mode: upsert
upsert_key: ["email"] # 如果电子邮件存在，则更新；否则插入。
batch_size: 1000
error_policy: skip # skip、abort 或 retry

```

## 2. 虚拟对象（外部数据源）

传统上，如果您想在您的应用中显示来自外部 ERP（例如 SAP 订单）的数据，您必须同步它（复制数据 = 陈旧数据）。

ObjectOS 引入了**虚拟对象**。您在 ObjectQL 中定义 Schema，但数据保留在外部系统中。ObjectOS 充当**实时代理**。

### 定义

```yaml
# objects/sap_order.object.yml
name: sap_order
label: SAP Sales Order
datasource: sap_erp_connector # 指向配置的 OData/REST 源
virtual: true # 数据不存储在 ObjectOS 数据库中

fields:
  order_number:
    type: text
    external_name: "OrderID" # 映射到远程 API 字段
    
  amount:
    type: currency
    external_name: "TotalNet"

```

### 透明查询

当前端请求：
`GET /api/objectql/sap_order?filters=[["amount", ">", 1000]]`

ObjectOS 内核实时将其转换为外部 API 调用：
`GET https://sap-gateway.com/Orders?$filter=TotalNet gt 1000`

UI 组件（网格）不知道区别。它就是有效。

## 3. Webhook 和事件集成

用于实时、事件驱动的集成。

### 入站 Webhook

您无需编写 Node.js 路由来处理 Stripe 支付，只需定义**Webhook 接收器**。

```yaml
# integration/webhooks/stripe_payment.yml
path: /webhooks/stripe
secret: "${env.STRIPE_SECRET}"

actions:
  - type: script
    code: |
      if (payload.type === 'payment_intent.succeeded') {
        const email = payload.data.object.receipt_email;
        // 调用内部 broker 来更新 Subscription
        await broker.call('subscription.renew', { email });
      }

```

### 出站 Webhook

当 ObjectOS 中的事件发生时，将数据推送到其他系统。

```yaml
# triggers/slack_notify.trigger.yml
object: incident
on: create
action: webhook.send
params:
  url: "[https://hooks.slack.com/](https://hooks.slack.com/)..."
  payload:
    text: "New Incident: ${doc.title}"

```

## 4. OData 和 GraphQL 标准

ObjectOS 不仅仅是 API 的消费者；它是标准 API 的**生产者**。

为了确保您的应用与更广泛的生态系统配合工作（Excel、PowerBI、Salesforce），ObjectOS 自动暴露标准端点。

### OData v4 支持

每个 ObjectQL Schema 都自动映射到 OData 元数据文档。

* **URL：** `/api/odata/v4/$metadata`
* **优势：** 您可以打开 Excel，转到"数据 > 获取数据 > 从 OData 源"，粘贴您的 ObjectOS URL，获取实时、可刷新的数据电子表格。**无需编码。**

### GraphQL 支持

对于喜欢 GraphQL 而不是 ObjectQL JSON 的前端开发人员。

* **URL：** `/graphql`
* **Schema：** 从对象定义即时生成。

## 5. 转换引擎

数据很少完全匹配。ObjectOS 提供了一种轻量级表达式语言（基于 JSONata）用于**有效负载转换**。

**场景：** 外部 API 发送 `{"user": {"first": "John", "last": "Doe"}}`，但您需要 `full_name`。

**转换定义：**

```yaml
transform:
  full_name: "${data.user.first} & ' ' & ${data.user.last}"
  status_code: "${data.isActive ? 'Active' : 'Inactive'}"

```

## 摘要

| 集成类型 | 模式 | 用例 |
| --- | --- | --- |
| **ETL 导入** | 批量 / 计划 | 迁移遗留数据、每月供应商 CSV。 |
| **虚拟对象** | 实时代理 | 查看 SAP 订单而不复制它们。 |
| **Webhook** | 事件驱动 | 实时支付确认、Slack 警报。 |
| **OData/GraphQL** | 标准协议 | BI 工具（PowerBI、Tableau）、第三方客户端。 |

:::tip 架构决定
当您需要查看数据但不拥有数据时，使用**虚拟对象**。
当您需要在该数据上运行复杂查询、报告或触发器时，使用 **ETL/同步**（因为外部 API 通常很慢或在过滤中受到限制）。
:::
