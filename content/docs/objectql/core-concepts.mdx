---
title: Core Concepts
description: Understanding Schema, Virtual City, and ObjectQL fundamentals
---

# Core Concepts

This guide explains the fundamental concepts that power ObjectQL's architecture and capabilities.

## What is Schema?

A **Schema** is a declarative definition of your data structure. Instead of writing SQL CREATE TABLE statements, you define your data model as JavaScript objects.

### Schema Structure

A Schema consists of **Objects** (similar to tables) and their **Fields** (similar to columns):

```typescript
const schema = {
  objects: {
    // Object name (singular)
    customer: {
      label: 'Customer',
      fields: {
        // Field definitions
        name: { 
          type: 'text', 
          label: 'Full Name',
          required: true 
        },
        email: { 
          type: 'email', 
          unique: true 
        },
        created_at: { 
          type: 'datetime',
          defaultValue: () => new Date()
        }
      }
    }
  }
}
```

### Why Schema?

**Benefits of Schema-driven architecture:**

1. **Database Independence** - Define once, run anywhere
2. **Type Safety** - Automatic validation and type checking
3. **Auto-migration** - Schema changes automatically sync to database
4. **Self-documenting** - Schema serves as living documentation
5. **Tooling Support** - IDE autocomplete, validation, and generation

### Schema Registration

Register your schema with ObjectQL:

```typescript
import { ObjectQL } from '@objectql/core'

const db = new ObjectQL({ 
  driver: 'sqlite', 
  url: './myapp.db' 
})

// Register schema
await db.registerSchema(schema)

// Now you can query your objects
const customers = await db.query('customer', {})
```

## Field Types

ObjectQL supports rich field types that map to appropriate database types:

### Basic Types

```typescript
{
  // Text types
  short_text: { type: 'text' },              // VARCHAR(255)
  long_text: { type: 'textarea' },           // TEXT
  rich_text: { type: 'html' },               // TEXT
  
  // Numeric types
  age: { type: 'number' },                   // INTEGER
  price: { type: 'currency', scale: 2 },     // DECIMAL(15,2)
  percentage: { type: 'percent' },           // DECIMAL(5,2)
  
  // Date/Time types
  birthday: { type: 'date' },                // DATE
  created_at: { type: 'datetime' },          // DATETIME
  
  // Boolean
  is_active: { type: 'boolean' },            // BOOLEAN
  
  // Select (enum)
  status: { 
    type: 'select', 
    options: ['draft', 'published', 'archived']
  },
  
  // JSON
  metadata: { type: 'json' }                 // JSON/TEXT
}
```

### Relationship Types

```typescript
{
  // Master-detail (foreign key)
  owner: {
    type: 'master_detail',
    reference_to: 'user',                    // References user._id
    required: true
  },
  
  // Lookup (optional reference)
  manager: {
    type: 'lookup',
    reference_to: 'user'
  }
}
```

## Field Constraints

Add validation and constraints to fields:

```typescript
{
  fields: {
    email: {
      type: 'email',
      required: true,           // NOT NULL
      unique: true,             // UNIQUE constraint
      index: true               // Create index
    },
    
    username: {
      type: 'text',
      minLength: 3,             // Validation
      maxLength: 20,
      pattern: '^[a-zA-Z0-9_]+$' // Regex validation
    },
    
    age: {
      type: 'number',
      min: 18,                  // Minimum value
      max: 120                  // Maximum value
    },
    
    status: {
      type: 'select',
      options: ['active', 'inactive'],
      defaultValue: 'active'    // Default value
    }
  }
}
```

## What is Virtual City?

**Virtual City** is ObjectQL's mechanism for **multi-tenant data isolation**. It creates logical data partitions within a single database, enabling secure multi-tenancy without database duplication.

### The Concept

Imagine a city where each tenant has their own "virtual building":

```
┌─────────────────────────────────────────┐
│          Physical Database              │
│                                         │
│  ┌──────────────┐  ┌──────────────┐   │
│  │ Virtual City │  │ Virtual City │   │
│  │  (Tenant A)  │  │  (Tenant B)  │   │
│  │              │  │              │   │
│  │  ┌────────┐  │  │  ┌────────┐  │   │
│  │  │Customers│  │  │  │Customers│  │   │
│  │  │Orders  │  │  │  │Orders  │  │   │
│  │  └────────┘  │  │  └────────┘  │   │
│  └──────────────┘  └──────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

### How It Works

ObjectQL automatically adds a `space` field to every record and filters queries by tenant:

```typescript
// Initialize main database
const db = new ObjectQL({ 
  driver: 'mysql',
  url: 'mysql://localhost/myapp' 
})

// Create virtual cities for tenants
const tenantA = db.virtualCity('tenant_a')
const tenantB = db.virtualCity('tenant_b')

// Each tenant sees only their own data
await tenantA.mutation('customer', {
  action: 'insert',
  data: { name: 'Customer A1' }
})

await tenantB.mutation('customer', {
  action: 'insert',
  data: { name: 'Customer B1' }
})

// Tenant A only sees their customers
const customersA = await tenantA.query('customer', {})
// Returns: [{ name: 'Customer A1', space: 'tenant_a' }]

// Tenant B only sees their customers
const customersB = await tenantB.query('customer', {})
// Returns: [{ name: 'Customer B1', space: 'tenant_b' }]
```

### Behind the Scenes

ObjectQL implements Virtual City through:

1. **Automatic Space Field** - Added to all tables
2. **Query Filtering** - Automatically adds `WHERE space = ?`
3. **Data Isolation** - Cross-tenant queries are impossible
4. **Index Optimization** - Composite indexes on `(space, ...)`

### Virtual City Use Cases

**Multi-tenant SaaS:**

```typescript
// Each customer gets isolated data
const customerDb = db.virtualCity(`customer_${customerId}`)
```

**Department Isolation:**

```typescript
// Separate data by department
const salesDb = db.virtualCity('dept_sales')
const hrDb = db.virtualCity('dept_hr')
```

**Environment Separation:**

```typescript
// Separate dev/staging/prod data in same database
const devDb = db.virtualCity('env_dev')
const prodDb = db.virtualCity('env_prod')
```

## System Fields

ObjectQL automatically adds system fields to every object:

```typescript
{
  _id: string           // Primary key (UUID)
  space: string         // Virtual City identifier
  created: datetime     // Creation timestamp
  created_by: string    // Creator user ID
  modified: datetime    // Last modification timestamp
  modified_by: string   // Last modifier user ID
  owner: string         // Record owner
}
```

These fields are:

- ✅ Automatically managed by ObjectQL
- ✅ Indexed for performance
- ✅ Available in all queries
- ✅ Used for audit trails

### Using System Fields

```typescript
// Query by creator
const myRecords = await db.query('customer', {
  filters: [['created_by', '=', currentUserId]]
})

// Sort by modification time
const recent = await db.query('customer', {
  sort: 'modified desc',
  limit: 10
})

// Track changes
const record = await db.query('customer', {
  filters: [['_id', '=', recordId]]
})

console.log(`Created by ${record.created_by} at ${record.created}`)
console.log(`Modified by ${record.modified_by} at ${record.modified}`)
```

## Schema Evolution

ObjectQL handles schema changes automatically:

### Adding Fields

```typescript
// Original schema
{
  objects: {
    customer: {
      fields: {
        name: { type: 'text' }
      }
    }
  }
}

// Updated schema - add email field
{
  objects: {
    customer: {
      fields: {
        name: { type: 'text' },
        email: { type: 'email' }  // New field
      }
    }
  }
}

// Re-register schema
await db.registerSchema(updatedSchema)
// ObjectQL automatically runs: ALTER TABLE customer ADD COLUMN email VARCHAR(255)
```

### Modifying Fields

```typescript
// Change field type
{
  email: { type: 'text' }  // Was 'email'
}

// ObjectQL handles data migration automatically
```

### Removing Fields

```typescript
// Remove field from schema
// ObjectQL marks field as deprecated but doesn't drop column
// This prevents data loss
```

## Best Practices

### Schema Design

1. **Use singular names** - `customer` not `customers`
2. **Be descriptive** - Use clear field names
3. **Add labels** - Help UI generation
4. **Set constraints** - Use required, unique, etc.
5. **Plan relationships** - Think about master-detail links

### Virtual City

1. **Consistent naming** - Use a convention like `tenant_{id}`
2. **Validate tenant IDs** - Ensure valid tenant before creating Virtual City
3. **Cache instances** - Reuse Virtual City instances
4. **Index strategy** - Ensure space is in composite indexes

### Performance

1. **Index frequently queried fields**
2. **Use appropriate field types**
3. **Limit JSON field usage**
4. **Leverage system field indexes**

## Next Steps

Now that you understand the core concepts:

- Learn the [Protocol Specification](/docs/objectql/protocol-spec) for detailed schema and query syntax
- Explore [Core Features](/docs/objectql/core-features) for advanced optimizations
- Master the [Server SDK](/docs/objectql/server-sdk) API
