---
title: Core Features
description: Advanced features including Virtual Column Index, cross-database drivers, and performance optimizations
---

# Core Features

ObjectQL provides advanced features that optimize performance and enable seamless cross-database support.

## Virtual Column Index for SQLite

**Virtual Column Index** is ObjectQL's performance optimization for SQLite that dramatically improves query speed on computed and relationship fields.

### The Problem

In traditional ORMs, querying related data requires expensive JOINs:

```sql
-- Traditional approach: JOIN query
SELECT o.*, u.name as owner_name
FROM orders o
LEFT JOIN users u ON o.owner_id = u._id
WHERE u.name LIKE '%john%'
-- This can be slow on large tables
```

### The Solution: Virtual Columns

ObjectQL creates **virtual indexed columns** for relationship fields:

```sql
-- ObjectQL automatically creates
ALTER TABLE orders ADD COLUMN owner_name_virtual TEXT;
CREATE INDEX idx_orders_owner_name ON orders(owner_name_virtual);

-- Updates happen automatically via triggers
CREATE TRIGGER update_owner_name_virtual
AFTER UPDATE ON users
BEGIN
  UPDATE orders SET owner_name_virtual = NEW.name
  WHERE owner_id = NEW._id;
END;
```

### How It Works

1. **Virtual Column Creation** - ObjectQL adds indexed virtual columns for lookup fields
2. **Automatic Sync** - Database triggers keep virtual columns synchronized
3. **Query Optimization** - Queries use indexed virtual columns instead of JOINs
4. **Transparent Operation** - Completely automatic, no code changes needed

### Example

```typescript
// Define schema with lookup
await db.registerSchema({
  objects: {
    order: {
      fields: {
        product: {
          type: 'lookup',
          reference_to: 'product'
        },
        customer: {
          type: 'lookup',
          reference_to: 'customer'
        },
        amount: { type: 'currency' }
      }
    }
  }
})

// Query with virtual column index
const orders = await db.query('order', {
  filters: [
    ['product.name', 'contains', 'laptop'],     // Uses virtual column
    ['customer.email', 'endswith', '@acme.com'] // Uses virtual column
  ]
})

// Behind the scenes:
// SELECT * FROM orders 
// WHERE product_name_virtual LIKE '%laptop%'
//   AND customer_email_virtual LIKE '%@acme.com'
// -- Fast! Uses indexes instead of JOINs
```

### Performance Comparison

```
Traditional JOIN Approach:
├── Orders: 100,000 records
├── Products: 10,000 records
└── Query time: ~2.5 seconds

Virtual Column Index:
├── Orders: 100,000 records (with virtual columns)
├── Indexed virtual columns
└── Query time: ~0.05 seconds (50x faster!)
```

### Configuration

Virtual Column Index is **enabled by default** for SQLite. Configure per field:

```typescript
{
  fields: {
    owner: {
      type: 'lookup',
      reference_to: 'user',
      virtual_index: true,        // Enable virtual index (default)
      virtual_fields: ['name', 'email']  // Fields to index
    }
  }
}
```

### Limitations

- **SQLite only** - Not needed for MySQL/PostgreSQL (they handle JOINs efficiently)
- **Write overhead** - Slight performance cost on updates (triggers execute)
- **Storage** - Additional disk space for virtual columns
- **Not real-time** - Brief delay during trigger execution

### Best Practices

1. **Enable for frequently queried fields**
2. **Limit virtual_fields** - Only index fields you search/filter on
3. **Monitor storage** - Virtual columns use disk space
4. **Use with large datasets** - Most beneficial for 10k+ records

## Cross-Database Driver Adaptation

ObjectQL provides a **unified API** across different database systems through intelligent driver adaptation.

### Supported Databases

```typescript
// SQLite (embedded)
const db = new ObjectQL({
  driver: 'sqlite',
  url: './data/myapp.db'
})

// MySQL
const db = new ObjectQL({
  driver: 'mysql',
  url: 'mysql://user:pass@localhost:3306/mydb'
})

// PostgreSQL
const db = new ObjectQL({
  driver: 'postgresql',
  url: 'postgresql://user:pass@localhost:5432/mydb'
})

// SQL Server
const db = new ObjectQL({
  driver: 'mssql',
  url: 'mssql://user:pass@localhost:1433/mydb'
})

// Oracle
const db = new ObjectQL({
  driver: 'oracle',
  url: 'oracle://user:pass@localhost:1521/mydb'
})
```

### Driver Architecture

```
┌─────────────────────────────────────────┐
│        ObjectQL Unified API             │
└────────────────┬────────────────────────┘
                 │
                 │
┌────────────────▼────────────────────────┐
│      Driver Abstraction Layer           │
│                                          │
│  ┌──────────────────────────────────┐  │
│  │   SQL Dialect Translator         │  │
│  │   - Type mapping                 │  │
│  │   - Syntax conversion            │  │
│  │   - Feature adaptation           │  │
│  └──────────────────────────────────┘  │
└────────────────┬────────────────────────┘
                 │
       ┌─────────┼─────────┐
       │         │         │
┌──────▼───┐ ┌──▼──────┐ ┌▼────────┐
│  SQLite  │ │  MySQL  │ │Postgres │
│  Driver  │ │  Driver │ │ Driver  │
└──────────┘ └─────────┘ └─────────┘
```

### Type Mapping

ObjectQL automatically maps field types to database-specific types:

```typescript
// ObjectQL Schema
{
  created_at: { type: 'datetime' },
  metadata: { type: 'json' },
  is_active: { type: 'boolean' }
}

// SQLite
CREATE TABLE (
  created_at TEXT,          -- ISO8601 string
  metadata TEXT,            -- JSON string
  is_active INTEGER         -- 0 or 1
)

// MySQL
CREATE TABLE (
  created_at DATETIME,
  metadata JSON,
  is_active BOOLEAN
)

// PostgreSQL
CREATE TABLE (
  created_at TIMESTAMP,
  metadata JSONB,           -- Binary JSON
  is_active BOOLEAN
)
```

### Dialect Translation

ObjectQL translates queries to database-specific SQL:

```typescript
// ObjectQL Query
await db.query('user', {
  filters: [['name', 'contains', 'john']],
  sort: 'created desc',
  limit: 10
})

// SQLite SQL
SELECT * FROM user 
WHERE name LIKE '%john%' COLLATE NOCASE
ORDER BY created DESC
LIMIT 10

// MySQL SQL
SELECT * FROM user 
WHERE LOWER(name) LIKE LOWER('%john%')
ORDER BY created DESC
LIMIT 10

// PostgreSQL SQL
SELECT * FROM user 
WHERE name ILIKE '%john%'
ORDER BY created DESC
LIMIT 10
```

### Feature Adaptation

ObjectQL adapts features based on database capabilities:

| Feature | SQLite | MySQL | PostgreSQL |
|---------|--------|-------|------------|
| Auto Increment | AUTOINCREMENT | AUTO_INCREMENT | SERIAL |
| JSON Fields | TEXT + parse | JSON | JSONB |
| Full-Text Search | FTS5 extension | FULLTEXT index | tsvector |
| UUID | TEXT | CHAR(36) | UUID type |
| Arrays | JSON array | JSON | ARRAY type |
| Virtual Columns | Yes (optimized) | Calculated | Generated |

## MySQL/PostgreSQL Driver Configuration

### MySQL Driver

#### Connection Options

```typescript
const db = new ObjectQL({
  driver: 'mysql',
  url: 'mysql://user:password@localhost:3306/database',
  
  // Or detailed config
  host: 'localhost',
  port: 3306,
  user: 'myapp_user',
  password: 'secure_password',
  database: 'myapp_db',
  
  // MySQL-specific options
  mysql: {
    charset: 'utf8mb4',
    timezone: '+00:00',
    connectTimeout: 10000,
    acquireTimeout: 10000,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    enableKeepAlive: true,
    keepAliveInitialDelay: 0,
    
    // SSL configuration
    ssl: {
      ca: fs.readFileSync('/path/to/ca.pem'),
      key: fs.readFileSync('/path/to/client-key.pem'),
      cert: fs.readFileSync('/path/to/client-cert.pem')
    }
  }
})
```

#### Performance Tuning

```typescript
// Connection pooling
{
  mysql: {
    connectionLimit: 20,        // Max connections
    queueLimit: 50,             // Max queued requests
    waitForConnections: true,   // Queue when limit reached
    
    // Timeouts
    connectTimeout: 10000,      // 10 seconds
    acquireTimeout: 10000,
    timeout: 60000,             // Query timeout
    
    // Keep-alive
    enableKeepAlive: true,
    keepAliveInitialDelay: 10000
  }
}
```

#### MySQL-Specific Features

```typescript
// Full-text search
await db.registerSchema({
  objects: {
    article: {
      fields: {
        title: { type: 'text' },
        content: { type: 'textarea' }
      },
      indexes: [
        {
          name: 'fulltext_search',
          type: 'FULLTEXT',
          fields: ['title', 'content']
        }
      ]
    }
  }
})

// Query with full-text search
const results = await db.query('article', {
  filters: [
    ['MATCH(title, content) AGAINST(?)', 'search terms']
  ]
})
```

### PostgreSQL Driver

#### Connection Options

```typescript
const db = new ObjectQL({
  driver: 'postgresql',
  url: 'postgresql://user:password@localhost:5432/database',
  
  // Or detailed config
  host: 'localhost',
  port: 5432,
  user: 'myapp_user',
  password: 'secure_password',
  database: 'myapp_db',
  
  // PostgreSQL-specific options
  postgres: {
    max: 20,                    // Max pool size
    min: 2,                     // Min pool size
    idle: 10000,                // Idle timeout
    connectionTimeoutMillis: 10000,
    idleTimeoutMillis: 30000,
    
    // SSL configuration
    ssl: {
      rejectUnauthorized: false,
      ca: fs.readFileSync('/path/to/ca.pem'),
      key: fs.readFileSync('/path/to/client-key.pem'),
      cert: fs.readFileSync('/path/to/client-cert.pem')
    },
    
    // Application name
    application_name: 'MyApp',
    
    // Statement timeout
    statement_timeout: 60000    // 60 seconds
  }
})
```

#### Performance Tuning

```typescript
{
  postgres: {
    // Connection pool
    max: 25,                    // Max connections
    min: 5,                     // Min idle connections
    
    // Timeouts
    connectionTimeoutMillis: 10000,
    idleTimeoutMillis: 30000,
    statement_timeout: 60000,
    
    // Keep-alive
    keepAlive: true,
    keepAliveInitialDelayMillis: 10000
  }
}
```

#### PostgreSQL-Specific Features

```typescript
// JSONB queries
await db.query('user', {
  filters: [
    ["metadata->>'city'", '=', 'New York'],
    ["metadata->'age'", '>', '18']
  ]
})

// Array fields
await db.registerSchema({
  objects: {
    post: {
      fields: {
        tags: { 
          type: 'array',
          items: { type: 'text' }
        }
      }
    }
  }
})

// Array queries
await db.query('post', {
  filters: [
    ['tags', '@>', ['javascript', 'nodejs']]  // Contains
  ]
})

// Full-text search
await db.query('article', {
  filters: [
    ["to_tsvector('english', content) @@ to_tsquery('search & terms')"]
  ]
})
```

### Connection Pool Monitoring

```typescript
// Get pool stats
const stats = await db.getPoolStats()
console.log({
  total: stats.total,           // Total connections
  idle: stats.idle,             // Idle connections
  waiting: stats.waiting        // Waiting requests
})

// Graceful shutdown
await db.close()
```

## Performance Best Practices

### Indexing Strategy

```typescript
{
  objects: {
    order: {
      fields: {
        customer_id: { type: 'lookup', reference_to: 'customer' },
        status: { type: 'select', options: [...] },
        created: { type: 'datetime' }
      },
      indexes: [
        // Composite index for common query
        {
          name: 'idx_customer_status',
          fields: ['customer_id', 'status']
        },
        // Date range queries
        {
          name: 'idx_created',
          fields: ['created']
        },
        // Virtual City + filters
        {
          name: 'idx_space_status',
          fields: ['space', 'status', 'created']
        }
      ]
    }
  }
}
```

### Query Optimization

```typescript
// ✅ Good: Use field selection
await db.query('customer', {
  fields: ['_id', 'name', 'email'],  // Only needed fields
  limit: 100
})

// ❌ Bad: Select all fields
await db.query('customer', {
  fields: ['*'],  // Retrieves all fields including large ones
  limit: 100
})

// ✅ Good: Use indexed filters
await db.query('order', {
  filters: [
    ['status', '=', 'pending'],      // Indexed
    ['created', '>', '2024-01-01']   // Indexed
  ]
})

// ❌ Bad: Function in filter
await db.query('order', {
  filters: [
    ['LOWER(status)', '=', 'pending']  // Can't use index
  ]
})
```

### Batch Operations

```typescript
// ✅ Good: Batch insert
await db.mutation('product', {
  action: 'insert',
  data: [
    { name: 'Product 1' },
    { name: 'Product 2' },
    // ... 100 records
  ]
})
// Single transaction, one round-trip

// ❌ Bad: Individual inserts
for (const product of products) {
  await db.mutation('product', {
    action: 'insert',
    data: product
  })
}
// 100 transactions, 100 round-trips
```

## Next Steps

- Master the [Server SDK](/docs/objectql/server-sdk) API
- Review [Protocol Spec](/docs/objectql/protocol-spec) for query syntax
- Check [Core Concepts](/docs/objectql/core-concepts) for fundamentals
