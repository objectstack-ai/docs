---
title: Deployment & Operations
description: Deploy ObjectOS in standalone, server, and multi-tenant modes
---

# Deployment & Operations

ObjectOS supports flexible deployment options to match your application needs: from single-file standalone executables to containerized multi-tenant SaaS platforms.

## Deployment Modes

ObjectOS can be deployed in three primary modes:

### 1. Standalone Mode

Single-file executable with embedded database for Local-First applications.

### 2. Server Mode

Traditional server deployment with external database for team collaboration.

### 3. Multi-Tenant Mode

SaaS-ready deployment with complete tenant isolation.

## Standalone Mode (.oos Files)

Standalone mode packages your application as a single executable `.oos` file with an embedded SQLite database.

### Creating a Standalone Application

```typescript
// app.ts - Your application definition
import { ObjectOS } from '@objectstack/os'

const app = new ObjectOS({
  mode: 'standalone',
  
  // Embedded storage
  storage: {
    type: 'sqlite',
    embedded: true  // Database bundled in .oos file
  },
  
  // Your schema
  schema: {
    objects: {
      tasks: {
        fields: {
          name: { type: 'text', required: true },
          completed: { type: 'boolean', defaultValue: false }
        }
      }
    }
  },
  
  // Your pages
  pages: {
    home: {
      type: 'list',
      object: 'tasks'
    }
  }
})

export default app
```

### Building the .oos File

```bash
# Install ObjectOS CLI
npm install -g @objectstack/cli

# Build standalone executable
objectos build app.ts --output myapp.oos

# Output: myapp.oos (single executable file)
```

### Running the .oos File

```bash
# Make executable (Linux/Mac)
chmod +x myapp.oos

# Run the application
./myapp.oos

# Application starts on http://localhost:3000
# Data stored in ~/.myapp/data.db by default
```

### .oos File Configuration

Users can configure the .oos file via environment variables:

```bash
# Custom data directory
DATA_DIR=~/Documents/myapp ./myapp.oos

# Custom port
PORT=8080 ./myapp.oos

# Enable sync
SYNC_ENABLED=true SYNC_URL=https://sync.example.com ./myapp.oos
```

### Distribution

Distribute your application as a single file:

```bash
# Cross-platform builds
objectos build app.ts --platform linux --output myapp-linux.oos
objectos build app.ts --platform macos --output myapp-macos.oos
objectos build app.ts --platform windows --output myapp.exe

# Users just download and run - no installation needed!
```

## Server Mode (Docker Deployment)

Server mode deploys ObjectOS as a containerized service with an external database.

### Basic Docker Deployment

Create a `Dockerfile`:

```dockerfile
FROM node:18-alpine

# Install dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci --production

# Copy application
COPY . .

# Build application
RUN npm run build

# Expose port
EXPOSE 3000

# Start application
CMD ["npm", "start"]
```

Create `docker-compose.yml`:

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
      - SESSION_SECRET=${SESSION_SECRET}
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - db-data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  db-data:
```

### Environment Variables

Configure your application via environment variables:

```bash
# Database connection
DATABASE_URL=postgresql://user:pass@host:5432/dbname

# Server settings
PORT=3000
HOST=0.0.0.0
NODE_ENV=production

# Authentication
SESSION_SECRET=your-secret-key-min-32-chars
JWT_SECRET=your-jwt-secret-key

# OAuth (optional)
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

# Email (optional)
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your-smtp-user
SMTP_PASS=your-smtp-password

# Storage (optional - for file uploads)
S3_BUCKET=your-bucket
S3_REGION=us-east-1
S3_ACCESS_KEY=your-access-key
S3_SECRET_KEY=your-secret-key

# Logging
LOG_LEVEL=info  # debug, info, warn, error
```

### Deploy with Docker Compose

```bash
# Start services
docker-compose up -d

# View logs
docker-compose logs -f app

# Stop services
docker-compose down

# Update application
docker-compose pull
docker-compose up -d --build
```

### Production Deployment

For production environments, add these configurations:

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - SESSION_SECRET=${SESSION_SECRET}
    deploy:
      replicas: 3  # Multiple instances
      restart_policy:
        condition: on-failure
        max_attempts: 3
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./backups:/backups
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
    depends_on:
      - app

volumes:
  db-data:
```

### Nginx Configuration

Create `nginx.conf` for reverse proxy:

```nginx
events {
    worker_connections 1024;
}

http {
    upstream app {
        least_conn;
        server app:3000;
    }

    server {
        listen 80;
        server_name example.com;

        # Redirect HTTP to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name example.com;

        # SSL certificates
        ssl_certificate /etc/nginx/certs/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/privkey.pem;

        # Security headers
        add_header Strict-Transport-Security "max-age=31536000" always;
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;

        # Proxy settings
        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # WebSocket support
        location /ws {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
    }
}
```

## Multi-Tenant SaaS Configuration

Deploy ObjectOS as a multi-tenant SaaS platform with complete tenant isolation.

### Multi-Tenant Architecture

ObjectOS supports two multi-tenant strategies:

#### 1. Virtual City Strategy (Recommended)

Uses ObjectQL's Virtual City mechanism for tenant isolation:

```typescript
const app = new ObjectOS({
  mode: 'multi-tenant',
  
  // Multi-tenant configuration
  multiTenant: {
    enabled: true,
    strategy: 'virtualCity',  // Use Virtual City
    isolation: 'strict',      // Strict tenant isolation
    
    // Tenant identification
    identifier: {
      type: 'subdomain',  // tenant1.app.com, tenant2.app.com
      // Or: type: 'header', header: 'X-Tenant-ID'
      // Or: type: 'path',   pattern: '/:tenantId/*'
    }
  },
  
  // Shared database
  storage: {
    type: 'postgresql',
    url: process.env.DATABASE_URL
  }
})
```

#### 2. Database-Per-Tenant Strategy

Separate database for each tenant:

```typescript
const app = new ObjectOS({
  mode: 'multi-tenant',
  
  multiTenant: {
    enabled: true,
    strategy: 'database',  // Separate databases
    
    // Database routing
    databaseResolver: async (tenantId) => {
      return {
        type: 'postgresql',
        url: `postgresql://user:pass@host:5432/tenant_${tenantId}`
      }
    }
  }
})
```

### Environment Variables for Multi-Tenant

```bash
# Multi-tenant mode
MULTI_TENANT=true
TENANT_STRATEGY=virtualCity  # or 'database'
TENANT_IDENTIFIER=subdomain   # 'subdomain', 'header', or 'path'

# Database
DATABASE_URL=postgresql://user:pass@host:5432/saas_app

# Tenant management
TENANT_AUTO_CREATE=false  # Don't auto-create tenants
TENANT_ADMIN_EMAIL=admin@example.com
```

### Docker Compose for Multi-Tenant

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - MULTI_TENANT=true
      - TENANT_STRATEGY=virtualCity
      - TENANT_IDENTIFIER=subdomain
      - DATABASE_URL=postgresql://postgres:password@db:5432/saas_app
      - SESSION_SECRET=${SESSION_SECRET}
    depends_on:
      - db
      - redis
    deploy:
      replicas: 3

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=saas_app
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - db-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  db-data:
  redis-data:
```

### Tenant Management

```typescript
// Create a new tenant
const tenant = await app.tenants.create({
  id: 'acme-corp',
  name: 'Acme Corporation',
  domain: 'acme.myapp.com',
  plan: 'enterprise',
  settings: {
    maxUsers: 100,
    maxStorage: '100GB'
  }
})

// List all tenants
const tenants = await app.tenants.list()

// Get tenant by ID
const tenant = await app.tenants.get('acme-corp')

// Update tenant
await app.tenants.update('acme-corp', {
  plan: 'enterprise-plus',
  settings: {
    maxUsers: 500
  }
})

// Delete tenant (with data)
await app.tenants.delete('acme-corp', {
  deleteData: true  // Permanently delete tenant data
})
```

## Database Migrations

Manage schema changes across deployments:

```bash
# Generate migration
objectos migrate create add-priority-field

# Apply migrations
objectos migrate up

# Rollback migrations
objectos migrate down

# Check migration status
objectos migrate status
```

Migration file example:

```typescript
// migrations/20240115_add_priority_field.ts
export async function up(db) {
  await db.addField('tasks', {
    priority: { 
      type: 'select',
      options: ['low', 'medium', 'high'],
      defaultValue: 'medium'
    }
  })
}

export async function down(db) {
  await db.removeField('tasks', 'priority')
}
```

## Monitoring & Logging

### Application Logging

```typescript
const app = new ObjectOS({
  logging: {
    level: 'info',  // debug, info, warn, error
    format: 'json', // json, text
    outputs: [
      { type: 'console' },
      { type: 'file', path: './logs/app.log' },
      { 
        type: 'cloudwatch',
        group: '/aws/objectos/myapp',
        stream: 'production'
      }
    ]
  }
})
```

### Health Checks

```typescript
// Built-in health check endpoint
// GET /health

{
  "status": "healthy",
  "database": "connected",
  "uptime": 86400,
  "memory": {
    "used": "256MB",
    "total": "1GB"
  }
}
```

### Metrics

```typescript
const app = new ObjectOS({
  metrics: {
    enabled: true,
    endpoint: '/metrics',  // Prometheus metrics
    include: [
      'http_requests',
      'db_queries',
      'cache_hits',
      'active_users'
    ]
  }
})
```

## Backup & Recovery

### Automated Backups

```bash
# Setup automated backups (PostgreSQL)
# Using pg_dump in cron

0 2 * * * docker exec db pg_dump -U postgres myapp > /backups/myapp-$(date +\%Y\%m\%d).sql

# Restore from backup
docker exec -i db psql -U postgres myapp < /backups/myapp-20240115.sql
```

### ObjectOS Backup API

```typescript
// Create backup
await app.backup.create({
  path: './backups/myapp-backup.db',
  includeFiles: true
})

// Restore from backup
await app.backup.restore({
  path: './backups/myapp-backup.db'
})
```

## Next Steps

You now know how to deploy ObjectOS in various configurations:

- **[Platform Architecture](./platform-architecture)** - Review platform architecture
- **[Identity & Access](./identity-access)** - Configure security and permissions
