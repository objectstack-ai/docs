---
title: Identity & Access Management
description: User system, RBAC model, and field-level security in ObjectOS
---

# Identity & Access Management

ObjectOS provides a comprehensive identity and access management system with built-in user management, role-based access control (RBAC), and field-level security (FLS). This enables you to build secure applications with fine-grained permissions.

## User System

ObjectOS includes a built-in user system based on the `_users` and `_roles` system objects.

### The `_users` Object

Every ObjectOS application has a system object `_users` that stores user information:

```typescript
// Built-in _users schema (system object)
{
  _users: {
    fields: {
      username: { type: 'text', required: true, unique: true },
      email: { type: 'email', required: true, unique: true },
      password: { type: 'password' },  // Hashed automatically
      name: { type: 'text' },
      profile: { type: 'lookup', reference_to: '_profiles' },
      roles: { type: 'lookup', reference_to: '_roles', multiple: true },
      active: { type: 'boolean', defaultValue: true },
      last_login: { type: 'datetime' },
      created: { type: 'datetime' },
      modified: { type: 'datetime' }
    }
  }
}
```

### User Authentication

ObjectOS supports multiple authentication methods:

```typescript
const app = new ObjectOS({
  auth: {
    enabled: true,
    providers: {
      // Email/Password authentication
      email: {
        enabled: true,
        requireVerification: true,
        passwordPolicy: {
          minLength: 8,
          requireUppercase: true,
          requireNumbers: true,
          requireSpecialChars: false
        }
      },
      
      // OAuth providers
      oauth: {
        google: {
          clientId: process.env.GOOGLE_CLIENT_ID,
          clientSecret: process.env.GOOGLE_CLIENT_SECRET
        },
        github: {
          clientId: process.env.GITHUB_CLIENT_ID,
          clientSecret: process.env.GITHUB_CLIENT_SECRET
        }
      },
      
      // SSO/SAML
      saml: {
        enabled: false,
        entryPoint: 'https://sso.example.com',
        cert: process.env.SAML_CERT
      }
    },
    
    // Session configuration
    session: {
      secret: process.env.SESSION_SECRET,
      maxAge: 86400000,  // 24 hours
      secure: true,
      sameSite: 'strict'
    }
  }
})
```

### User Registration

```typescript
// Register a new user
const newUser = await app.auth.register({
  username: 'john_doe',
  email: 'john@example.com',
  password: 'SecurePass123',
  name: 'John Doe'
})

// User is automatically created in _users object
// Password is hashed using bcrypt
```

### User Login

```typescript
// Email/password login
const session = await app.auth.login({
  email: 'john@example.com',
  password: 'SecurePass123'
})

// Returns session token
console.log(session.token)
console.log(session.user)
```

## Role-Based Access Control (RBAC)

ObjectOS implements a flexible RBAC system using the `_roles` object.

### The `_roles` Object

```typescript
// Built-in _roles schema (system object)
{
  _roles: {
    fields: {
      name: { type: 'text', required: true, unique: true },
      label: { type: 'text' },
      description: { type: 'text' },
      permissions: { type: 'json' },  // Permission definitions
      users: { type: 'lookup', reference_to: '_users', multiple: true },
      created: { type: 'datetime' },
      modified: { type: 'datetime' }
    }
  }
}
```

### Creating Roles

```typescript
// Create an Admin role
await app.mutation('_roles', {
  action: 'insert',
  data: {
    name: 'admin',
    label: 'Administrator',
    description: 'Full system access',
    permissions: {
      // Object-level permissions
      objects: {
        '*': {  // All objects
          allowCreate: true,
          allowRead: true,
          allowEdit: true,
          allowDelete: true
        }
      },
      // System permissions
      system: {
        manageUsers: true,
        manageRoles: true,
        viewAuditLog: true
      }
    }
  }
})

// Create a User role
await app.mutation('_roles', {
  action: 'insert',
  data: {
    name: 'user',
    label: 'Standard User',
    description: 'Basic access',
    permissions: {
      objects: {
        tasks: {
          allowCreate: true,
          allowRead: true,
          allowEdit: "owner eq $user.id",  // Can only edit own tasks
          allowDelete: "owner eq $user.id"
        },
        projects: {
          allowCreate: false,
          allowRead: true,
          allowEdit: false,
          allowDelete: false
        }
      }
    }
  }
})
```

### Assigning Roles to Users

```typescript
// Assign role to user
await app.mutation('_users', {
  action: 'update',
  _id: userId,
  data: {
    roles: [adminRoleId, userRoleId]
  }
})

// Users can have multiple roles
// Permissions are merged (most permissive wins)
```

### Permission Schema

ObjectOS supports rich permission expressions:

```typescript
{
  permissions: {
    objects: {
      // Specific object
      contacts: {
        // Boolean permissions
        allowCreate: true,
        allowRead: true,
        
        // Conditional permissions (filter expression)
        allowEdit: "owner eq $user.id or assigned_to eq $user.id",
        allowDelete: "owner eq $user.id",
        
        // Field-level permissions (see FLS section)
        fieldPermissions: {
          salary: {
            allowRead: "$user.role eq 'hr'",
            allowEdit: "$user.role eq 'hr'"
          }
        }
      },
      
      // Wildcard for all objects
      '*': {
        allowRead: true
      }
    },
    
    // System-level permissions
    system: {
      manageUsers: false,
      manageRoles: false,
      viewAuditLog: false,
      exportData: false
    }
  }
}
```

## Field-Level Security (FLS)

Field-Level Security allows you to hide or protect sensitive fields based on user permissions.

### Defining Field-Level Security

Define FLS in the schema:

```typescript
const schema = {
  objects: {
    employees: {
      fields: {
        name: { type: 'text' },
        email: { type: 'email' },
        department: { type: 'text' },
        
        // Sensitive field
        salary: { 
          type: 'number',
          security: {
            read: "$user.role eq 'hr' or $user.role eq 'admin'",
            edit: "$user.role eq 'hr'"
          }
        },
        
        // Highly sensitive field
        ssn: {
          type: 'text',
          security: {
            read: "$user.role eq 'admin'",
            edit: false  // Never editable
          }
        }
      }
    }
  }
}
```

### FLS Behavior

When FLS is applied:

```typescript
// HR user queries employees
const employees = await app.query('employees', {}, { user: hrUser })

// Result includes salary field:
// [
//   { name: 'John', email: 'john@ex.com', salary: 50000, ... }
// ]

// Regular user queries employees
const employees = await app.query('employees', {}, { user: regularUser })

// Result EXCLUDES salary field:
// [
//   { name: 'John', email: 'john@ex.com', ... }
// ]
// Field is completely hidden, not just null
```

### FLS in Role Permissions

You can also define FLS in role permissions:

```typescript
await app.mutation('_roles', {
  action: 'insert',
  data: {
    name: 'sales',
    label: 'Sales Team',
    permissions: {
      objects: {
        customers: {
          allowRead: true,
          allowEdit: "owner eq $user.id",
          
          // Field-level permissions
          fieldPermissions: {
            credit_card: {
              allowRead: false,  // Never see credit cards
              allowEdit: false
            },
            internal_notes: {
              allowRead: "$user.department eq 'sales'",
              allowEdit: "$user.role eq 'sales_manager'"
            }
          }
        }
      }
    }
  }
})
```

## Permission Evaluation

ObjectOS evaluates permissions in the following order:

### 1. System Object Protection

```typescript
// System objects (_users, _roles, etc.) have default protection
// Only admins can access by default
```

### 2. Object-Level Permissions

```typescript
// Check if user can perform action on object
if (!hasPermission(user, 'contacts', 'read')) {
  throw new PermissionError('Cannot read contacts')
}
```

### 3. Record-Level Permissions

```typescript
// Filter records based on conditional permissions
const filters = buildPermissionFilters(user, 'contacts', 'read')
// e.g., [['owner', 'eq', user.id], 'or', ['public', 'eq', true]]
```

### 4. Field-Level Security

```typescript
// Remove fields user cannot access
const visibleFields = filterFieldsByPermissions(user, 'contacts', fields)
```

### Permission Context Variables

Available in permission expressions:

```typescript
// Permission expression context
{
  $user: {
    id: 'user_id',
    username: 'john_doe',
    email: 'john@example.com',
    role: 'admin',  // Primary role
    roles: ['admin', 'user'],  // All roles
    department: 'engineering',
    // ... custom user fields
  },
  
  $record: {
    // Current record being accessed
    owner: 'record_owner_id',
    status: 'active',
    // ... all record fields
  }
}

// Example permission expressions:
"owner eq $user.id"                          // User owns record
"$user.role eq 'admin'"                      // User is admin
"status eq 'published' or owner eq $user.id" // Published or owned
"department eq $user.department"             // Same department
```

## Advanced Scenarios

### Hierarchical Roles

```typescript
// Define role hierarchy
const roles = [
  {
    name: 'admin',
    inherits: []  // Top level
  },
  {
    name: 'manager',
    inherits: ['user']  // Has all user permissions plus more
  },
  {
    name: 'user',
    inherits: []
  }
]
```

### Dynamic Permissions

```typescript
// Compute permissions at runtime
const schema = {
  objects: {
    documents: {
      permission_set: {
        user_permission: {
          allowRead: async (user, record) => {
            // Custom logic
            if (record.public) return true
            if (record.owner === user.id) return true
            
            // Check team membership
            const team = await app.query('teams', {
              filters: [
                ['members', 'contains', user.id],
                ['documents', 'contains', record.id]
              ]
            })
            
            return team.length > 0
          }
        }
      }
    }
  }
}
```

### Audit Logging

```typescript
const app = new ObjectOS({
  audit: {
    enabled: true,
    logLevel: 'all',  // 'all', 'mutations', 'sensitive'
    logFields: true,  // Log field-level changes
    retention: 90     // Days to retain logs
  }
})

// Query audit log
const auditLog = await app.query('_audit_log', {
  filters: [
    ['user_id', 'eq', userId],
    ['action', 'eq', 'delete']
  ],
  sort: 'created desc'
})
```

## Security Best Practices

### 1. Principle of Least Privilege

```typescript
// Start with minimal permissions
// Grant additional permissions as needed
permissions: {
  objects: {
    '*': {
      allowRead: false,
      allowCreate: false,
      allowEdit: false,
      allowDelete: false
    },
    // Only grant what's needed
    tasks: {
      allowRead: true,
      allowCreate: true
    }
  }
}
```

### 2. Protect Sensitive Fields

```typescript
// Always use FLS for sensitive data
{
  password: { 
    type: 'password',
    security: {
      read: false,   // Never readable
      edit: false    // Only via special API
    }
  },
  api_key: {
    type: 'text',
    security: {
      read: "$user.id eq $record.owner",
      edit: "$user.id eq $record.owner"
    }
  }
}
```

### 3. Regular Permission Audits

```typescript
// Review role permissions regularly
const roles = await app.query('_roles', {})

for (const role of roles) {
  console.log(`Role: ${role.name}`)
  console.log(JSON.stringify(role.permissions, null, 2))
  
  // Check for overly permissive settings
  if (role.permissions.objects['*']?.allowDelete) {
    console.warn('⚠️  Role has wildcard delete permission')
  }
}
```

## Next Steps

Now that you understand identity and access management:

- **[Deployment & Operations](/docs/04-objectos/deployment)** - Learn how to deploy ObjectOS applications
- **[Platform Architecture](/docs/04-objectos/platform-architecture)** - Review the platform architecture
