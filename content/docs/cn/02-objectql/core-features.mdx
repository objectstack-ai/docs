---
title: 核心功能
description: 高级功能,包括虚拟列索引、跨数据库驱动和性能优化
---

# 核心功能

ObjectQL 提供高级功能,优化性能并实现无缝的跨数据库支持。

## SQLite 虚拟列索引

**虚拟列索引**是 ObjectQL 针对 SQLite 的性能优化,可显著提高计算字段和关系字段的查询速度。

### 问题所在

在传统 ORM 中,查询关联数据需要昂贵的 JOIN 操作:

```sql
-- 传统方法: JOIN 查询
SELECT o.*, u.name as owner_name
FROM orders o
LEFT JOIN users u ON o.owner_id = u._id
WHERE u.name LIKE '%john%'
-- 在大表上可能很慢
```

### 解决方案: 虚拟列

ObjectQL 为关系字段创建**虚拟索引列**:

```sql
-- ObjectQL 自动创建
ALTER TABLE orders ADD COLUMN owner_name_virtual TEXT;
CREATE INDEX idx_orders_owner_name ON orders(owner_name_virtual);

-- 通过触发器自动更新
CREATE TRIGGER update_owner_name_virtual
AFTER UPDATE ON users
BEGIN
  UPDATE orders SET owner_name_virtual = NEW.name
  WHERE owner_id = NEW._id;
END;
```

### 工作原理

1. **虚拟列创建** - ObjectQL 为查找字段添加索引虚拟列
2. **自动同步** - 数据库触发器保持虚拟列同步
3. **查询优化** - 查询使用索引虚拟列而不是 JOIN
4. **透明操作** - 完全自动,无需更改代码

### 示例

```typescript
// 定义带查找的 Schema
await db.registerSchema({
  objects: {
    order: {
      fields: {
        product: {
          type: 'lookup',
          reference_to: 'product'
        },
        customer: {
          type: 'lookup',
          reference_to: 'customer'
        },
        amount: { type: 'currency' }
      }
    }
  }
})

// 使用虚拟列索引查询
const orders = await db.query('order', {
  filters: [
    ['product.name', 'contains', 'laptop'],     // 使用虚拟列
    ['customer.email', 'endswith', '@acme.com'] // 使用虚拟列
  ]
})

// 底层实现:
// SELECT * FROM orders 
// WHERE product_name_virtual LIKE '%laptop%'
//   AND customer_email_virtual LIKE '%@acme.com'
// -- 快速! 使用索引而不是 JOIN
```

### 性能对比

```
传统 JOIN 方法:
├── Orders: 100,000 条记录
├── Products: 10,000 条记录
└── 查询时间: ~2.5 秒

虚拟列索引:
├── Orders: 100,000 条记录(带虚拟列)
├── 索引虚拟列
└── 查询时间: ~0.05 秒 (快 50 倍!)
```

### 配置

虚拟列索引对 SQLite **默认启用**。可按字段配置:

```typescript
{
  fields: {
    owner: {
      type: 'lookup',
      reference_to: 'user',
      virtual_index: true,        // 启用虚拟索引(默认)
      virtual_fields: ['name', 'email']  // 要索引的字段
    }
  }
}
```

### 限制

- **仅 SQLite** - MySQL/PostgreSQL 不需要(它们能高效处理 JOIN)
- **写入开销** - 更新时有轻微性能损耗(触发器执行)
- **存储空间** - 虚拟列需要额外磁盘空间
- **非实时** - 触发器执行期间有短暂延迟

### 最佳实践

1. **为频繁查询的字段启用**
2. **限制 virtual_fields** - 仅索引搜索/过滤的字段
3. **监控存储** - 虚拟列占用磁盘空间
4. **用于大数据集** - 对 1 万条以上记录最有益

## 跨数据库驱动适配

ObjectQL 通过智能驱动适配提供跨不同数据库系统的**统一 API**。

### 支持的数据库

```typescript
// SQLite (嵌入式)
const db = new ObjectQL({
  driver: 'sqlite',
  url: './data/myapp.db'
})

// MySQL
const db = new ObjectQL({
  driver: 'mysql',
  url: 'mysql://user:pass@localhost:3306/mydb'
})

// PostgreSQL
const db = new ObjectQL({
  driver: 'postgresql',
  url: 'postgresql://user:pass@localhost:5432/mydb'
})

// SQL Server
const db = new ObjectQL({
  driver: 'mssql',
  url: 'mssql://user:pass@localhost:1433/mydb'
})

// Oracle
const db = new ObjectQL({
  driver: 'oracle',
  url: 'oracle://user:pass@localhost:1521/mydb'
})
```

### 驱动架构

```
┌─────────────────────────────────────────┐
│        ObjectQL 统一 API                 │
└────────────────┬────────────────────────┘
                 │
                 │
┌────────────────▼────────────────────────┐
│      驱动抽象层                          │
│                                          │
│  ┌──────────────────────────────────┐  │
│  │   SQL 方言转换器                  │  │
│  │   - 类型映射                      │  │
│  │   - 语法转换                      │  │
│  │   - 功能适配                      │  │
│  └──────────────────────────────────┘  │
└────────────────┬────────────────────────┘
                 │
       ┌─────────┼─────────┐
       │         │         │
┌──────▼───┐ ┌──▼──────┐ ┌▼────────┐
│  SQLite  │ │  MySQL  │ │Postgres │
│  驱动    │ │  驱动   │ │  驱动   │
└──────────┘ └─────────┘ └─────────┘
```

### 类型映射

ObjectQL 自动将字段类型映射到数据库特定类型:

```typescript
// ObjectQL Schema
{
  created_at: { type: 'datetime' },
  metadata: { type: 'json' },
  is_active: { type: 'boolean' }
}

// SQLite
CREATE TABLE (
  created_at TEXT,          -- ISO8601 字符串
  metadata TEXT,            -- JSON 字符串
  is_active INTEGER         -- 0 或 1
)

// MySQL
CREATE TABLE (
  created_at DATETIME,
  metadata JSON,
  is_active BOOLEAN
)

// PostgreSQL
CREATE TABLE (
  created_at TIMESTAMP,
  metadata JSONB,           -- 二进制 JSON
  is_active BOOLEAN
)
```

### 方言转换

ObjectQL 将查询转换为数据库特定的 SQL:

```typescript
// ObjectQL 查询
await db.query('user', {
  filters: [['name', 'contains', 'john']],
  sort: 'created desc',
  limit: 10
})

// SQLite SQL
SELECT * FROM user 
WHERE name LIKE '%john%' COLLATE NOCASE
ORDER BY created DESC
LIMIT 10

// MySQL SQL
SELECT * FROM user 
WHERE LOWER(name) LIKE LOWER('%john%')
ORDER BY created DESC
LIMIT 10

// PostgreSQL SQL
SELECT * FROM user 
WHERE name ILIKE '%john%'
ORDER BY created DESC
LIMIT 10
```

### 功能适配

ObjectQL 根据数据库能力适配功能:

| 功能 | SQLite | MySQL | PostgreSQL |
|------|--------|-------|------------|
| 自动递增 | AUTOINCREMENT | AUTO_INCREMENT | SERIAL |
| JSON 字段 | TEXT + 解析 | JSON | JSONB |
| 全文搜索 | FTS5 扩展 | FULLTEXT 索引 | tsvector |
| UUID | TEXT | CHAR(36) | UUID 类型 |
| 数组 | JSON 数组 | JSON | ARRAY 类型 |
| 虚拟列 | 是(优化) | 计算列 | 生成列 |

## MySQL/PostgreSQL 驱动配置

### MySQL 驱动

#### 连接选项

```typescript
const db = new ObjectQL({
  driver: 'mysql',
  url: 'mysql://user:password@localhost:3306/database',
  
  // 或详细配置
  host: 'localhost',
  port: 3306,
  user: 'myapp_user',
  password: 'secure_password',
  database: 'myapp_db',
  
  // MySQL 特定选项
  mysql: {
    charset: 'utf8mb4',
    timezone: '+00:00',
    connectTimeout: 10000,
    acquireTimeout: 10000,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    enableKeepAlive: true,
    keepAliveInitialDelay: 0,
    
    // SSL 配置
    ssl: {
      ca: fs.readFileSync('/path/to/ca.pem'),
      key: fs.readFileSync('/path/to/client-key.pem'),
      cert: fs.readFileSync('/path/to/client-cert.pem')
    }
  }
})
```

#### 性能调优

```typescript
// 连接池
{
  mysql: {
    connectionLimit: 20,        // 最大连接数
    queueLimit: 50,             // 最大排队请求数
    waitForConnections: true,   // 达到限制时排队
    
    // 超时设置
    connectTimeout: 10000,      // 10 秒
    acquireTimeout: 10000,
    timeout: 60000,             // 查询超时
    
    // 保持连接
    enableKeepAlive: true,
    keepAliveInitialDelay: 10000
  }
}
```

#### MySQL 特定功能

```typescript
// 全文搜索
await db.registerSchema({
  objects: {
    article: {
      fields: {
        title: { type: 'text' },
        content: { type: 'textarea' }
      },
      indexes: [
        {
          name: 'fulltext_search',
          type: 'FULLTEXT',
          fields: ['title', 'content']
        }
      ]
    }
  }
})

// 使用全文搜索查询
const results = await db.query('article', {
  filters: [
    ['MATCH(title, content) AGAINST(?)', '搜索词']
  ]
})
```

### PostgreSQL 驱动

#### 连接选项

```typescript
const db = new ObjectQL({
  driver: 'postgresql',
  url: 'postgresql://user:password@localhost:5432/database',
  
  // 或详细配置
  host: 'localhost',
  port: 5432,
  user: 'myapp_user',
  password: 'secure_password',
  database: 'myapp_db',
  
  // PostgreSQL 特定选项
  postgres: {
    max: 20,                    // 最大池大小
    min: 2,                     // 最小池大小
    idle: 10000,                // 空闲超时
    connectionTimeoutMillis: 10000,
    idleTimeoutMillis: 30000,
    
    // SSL 配置
    ssl: {
      rejectUnauthorized: false,
      ca: fs.readFileSync('/path/to/ca.pem'),
      key: fs.readFileSync('/path/to/client-key.pem'),
      cert: fs.readFileSync('/path/to/client-cert.pem')
    },
    
    // 应用名称
    application_name: 'MyApp',
    
    // 语句超时
    statement_timeout: 60000    // 60 秒
  }
})
```

#### 性能调优

```typescript
{
  postgres: {
    // 连接池
    max: 25,                    // 最大连接数
    min: 5,                     // 最小空闲连接数
    
    // 超时设置
    connectionTimeoutMillis: 10000,
    idleTimeoutMillis: 30000,
    statement_timeout: 60000,
    
    // 保持连接
    keepAlive: true,
    keepAliveInitialDelayMillis: 10000
  }
}
```

#### PostgreSQL 特定功能

```typescript
// JSONB 查询
await db.query('user', {
  filters: [
    ["metadata->>'city'", '=', 'New York'],
    ["metadata->'age'", '>', '18']
  ]
})

// 数组字段
await db.registerSchema({
  objects: {
    post: {
      fields: {
        tags: { 
          type: 'array',
          items: { type: 'text' }
        }
      }
    }
  }
})

// 数组查询
await db.query('post', {
  filters: [
    ['tags', '@>', ['javascript', 'nodejs']]  // 包含
  ]
})

// 全文搜索
await db.query('article', {
  filters: [
    ["to_tsvector('english', content) @@ to_tsquery('search & terms')"]
  ]
})
```

### 连接池监控

```typescript
// 获取池统计
const stats = await db.getPoolStats()
console.log({
  total: stats.total,           // 总连接数
  idle: stats.idle,             // 空闲连接数
  waiting: stats.waiting        // 等待请求数
})

// 优雅关闭
await db.close()
```

## 性能最佳实践

### 索引策略

```typescript
{
  objects: {
    order: {
      fields: {
        customer_id: { type: 'lookup', reference_to: 'customer' },
        status: { type: 'select', options: [...] },
        created: { type: 'datetime' }
      },
      indexes: [
        // 常用查询的复合索引
        {
          name: 'idx_customer_status',
          fields: ['customer_id', 'status']
        },
        // 日期范围查询
        {
          name: 'idx_created',
          fields: ['created']
        },
        // Virtual City + 过滤器
        {
          name: 'idx_space_status',
          fields: ['space', 'status', 'created']
        }
      ]
    }
  }
}
```

### 查询优化

```typescript
// ✅ 好: 使用字段选择
await db.query('customer', {
  fields: ['_id', 'name', 'email'],  // 只要需要的字段
  limit: 100
})

// ❌ 差: 选择所有字段
await db.query('customer', {
  fields: ['*'],  // 检索所有字段包括大字段
  limit: 100
})

// ✅ 好: 使用索引过滤器
await db.query('order', {
  filters: [
    ['status', '=', 'pending'],      // 已索引
    ['created', '>', '2024-01-01']   // 已索引
  ]
})

// ❌ 差: 过滤器中使用函数
await db.query('order', {
  filters: [
    ['LOWER(status)', '=', 'pending']  // 无法使用索引
  ]
})
```

### 批量操作

```typescript
// ✅ 好: 批量插入
await db.mutation('product', {
  action: 'insert',
  data: [
    { name: '产品 1' },
    { name: '产品 2' },
    // ... 100 条记录
  ]
})
// 单个事务,一次往返

// ❌ 差: 单独插入
for (const product of products) {
  await db.mutation('product', {
    action: 'insert',
    data: product
  })
}
// 100 个事务,100 次往返
```

## 下一步

- 掌握[服务端 SDK](/docs/02-objectql/server-sdk) API
- 查看[协议规范](/docs/02-objectql/protocol-spec)了解查询语法
- 查看[核心概念](/docs/02-objectql/core-concepts)了解基础知识
