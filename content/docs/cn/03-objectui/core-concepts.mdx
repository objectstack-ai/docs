---
title: 核心概念
description: 理解声明式 UI、数据驱动渲染和 ObjectUI 原则
---

# 核心概念

本指南解释了支撑 ObjectUI 声明式和数据驱动架构的基本概念。

## 声明式 UI vs 命令式 UI

理解声明式和命令式方法之间的区别是掌握 ObjectUI 的关键。

### 命令式 UI

在传统的命令式 UI 开发中,您编写代码描述**如何**构建和更新界面:

```tsx
// 命令式方法 - 描述如何做
function UserProfile() {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [])
  
  if (loading) return <div>加载中...</div>
  if (error) return <div>错误: {error}</div>
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => {
        fetch('/api/user', { method: 'DELETE' })
          .then(() => window.location.href = '/users')
      }}>
        删除用户
      </button>
    </div>
  )
}
```

**特点:**
- 您管理状态 (`useState`, `useEffect`)
- 您手动处理数据获取
- 您编写事件处理器
- 您控制渲染逻辑
- 更多代码,更多维护

### 声明式 UI

在 ObjectUI 的声明式方法中,您描述**想要什么**,而不是如何构建:

```json
{
  "type": "card",
  "title": "${name}",
  "api": "/api/user",
  "body": [
    { "type": "text", "value": "邮箱: ${email}" }
  ],
  "actions": [
    {
      "label": "删除用户",
      "api": "/api/user",
      "method": "DELETE",
      "confirm": "确定要删除吗?",
      "onSuccess": { "type": "redirect", "url": "/users" }
    }
  ]
}
```

**特点:**
- 无状态管理代码
- 自动数据获取
- 声明式操作
- 内置错误处理
- 更少代码,更易维护

### 声明式 UI 的优势

1. **简单性** - 描述想要什么,而不是如何构建
2. **一致性** - 所有组件遵循相同的模式
3. **可维护性** - 更少的代码意味着更少的 bug
4. **灵活性** - UI 可以在不改变代码的情况下修改
5. **可移植性** - JSON 协议可以存储、版本化和共享
6. **动态生成** - UI 可以通过编程或从数据库生成

## 数据驱动渲染

ObjectUI 组件是**数据驱动**的,这意味着 UI 自动反映底层数据。

### 数据流

```
┌──────────────┐
│   协议       │  → 定义结构和行为
│   (JSON)     │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   数据       │  → 提供内容
│  (API/Props) │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  渲染的 UI   │  → 自动渲染
│              │
└──────────────┘
```

### 数据源

ObjectUI 组件可以从多个源接收数据:

#### 1. API 端点

自动从 API 获取数据:

```json
{
  "type": "table",
  "api": "/api/users",
  "columns": [
    { "name": "name", "label": "姓名" },
    { "name": "email", "label": "邮箱" }
  ]
}
```

组件会:
- 挂载时从 `/api/users` 获取数据
- 处理加载状态
- 请求失败时显示错误
- 参数变化时重新获取

#### 2. 静态数据

直接在协议中提供数据:

```json
{
  "type": "select",
  "name": "priority",
  "label": "优先级",
  "options": [
    { "label": "高", "value": "high" },
    { "label": "中", "value": "medium" },
    { "label": "低", "value": "low" }
  ]
}
```

#### 3. 上下文数据

从父组件访问数据:

```json
{
  "type": "form",
  "api": "/api/users/${userId}",
  "fields": [
    { "name": "name", "type": "input" },
    { "name": "email", "type": "input" }
  ]
}
```

`${userId}` 从上下文中解析(URL 参数、父状态等)

### 响应式更新

当数据变化时,UI 自动更新:

```json
{
  "type": "card",
  "api": "/api/stats",
  "refresh": 5000,
  "body": [
    { "type": "text", "value": "活跃用户: ${activeUsers}" },
    { "type": "text", "value": "总订单: ${totalOrders}" }
  ]
}
```

这个卡片会:
- 从 `/api/stats` 获取初始数据
- 每 5 秒自动刷新
- 数据变化时更新显示值

## 协议结构

每个 ObjectUI 组件都遵循一致的协议结构:

### 基本协议

```typescript
{
  // 组件类型 (必需)
  type: 'input' | 'select' | 'table' | 'form' | 'page' | ...,
  
  // 通用属性
  name?: string,           // 表单字段名
  label?: string,          // 显示标签
  visible?: boolean,       // 可见性控制
  disabled?: boolean,      // 禁用状态
  
  // 数据属性
  value?: any,            // 静态值
  defaultValue?: any,     // 默认值
  api?: string,           // 数据的 API 端点
  
  // 事件处理器
  onChange?: Action,      // 变化处理器
  onClick?: Action,       // 点击处理器
  
  // 样式
  className?: string,     // CSS 类
  style?: object,         // 内联样式
}
```

### 组件特定属性

每种组件类型都有额外的特定属性:

```json
{
  "type": "input",
  "placeholder": "输入文本...",
  "maxLength": 100
}
```

```json
{
  "type": "table",
  "columns": [...],
  "pagination": true,
  "pageSize": 20
}
```

## 模板表达式

ObjectUI 支持动态值的模板表达式:

### 简单变量

```json
{
  "type": "text",
  "value": "你好, ${userName}!"
}
```

### 嵌套属性

```json
{
  "type": "text",
  "value": "${user.profile.firstName} ${user.profile.lastName}"
}
```

### 条件显示

```json
{
  "type": "badge",
  "value": "${status}",
  "visible": "${status === 'active'}"
}
```

### 数组访问

```json
{
  "type": "text",
  "value": "第一项: ${items[0].name}"
}
```

## 操作(Actions)

操作定义 ObjectUI 中的交互行为:

### 操作类型

#### 1. API 请求

发起 HTTP 请求:

```json
{
  "type": "button",
  "label": "提交",
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "method": "POST",
    "data": "${formData}"
  }
}
```

#### 2. 导航

导航到不同页面:

```json
{
  "type": "button",
  "label": "查看详情",
  "onClick": {
    "type": "navigate",
    "url": "/users/${id}"
  }
}
```

#### 3. 对话框

打开对话框或模态框:

```json
{
  "type": "button",
  "label": "编辑",
  "onClick": {
    "type": "dialog",
    "title": "编辑用户",
    "body": {
      "type": "form",
      "fields": [...]
    }
  }
}
```

#### 4. 提示/消息

显示通知:

```json
{
  "type": "button",
  "label": "保存",
  "onClick": {
    "type": "toast",
    "message": "保存成功!",
    "variant": "success"
  }
}
```

#### 5. 设置状态

更新组件状态:

```json
{
  "type": "button",
  "label": "切换",
  "onClick": {
    "type": "setState",
    "key": "isExpanded",
    "value": "${!isExpanded}"
  }
}
```

### 操作链

按顺序执行多个操作:

```json
{
  "type": "button",
  "label": "删除",
  "onClick": [
    {
      "type": "api",
      "api": "/api/users/${id}",
      "method": "DELETE"
    },
    {
      "type": "toast",
      "message": "用户已删除"
    },
    {
      "type": "navigate",
      "url": "/users"
    }
  ]
}
```

### 条件操作

基于条件执行操作:

```json
{
  "type": "button",
  "label": "提交",
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "method": "POST",
    "onSuccess": {
      "type": "toast",
      "message": "成功!"
    },
    "onError": {
      "type": "toast",
      "message": "错误: ${error}",
      "variant": "error"
    }
  }
}
```

## 组件生命周期

ObjectUI 组件有可预测的生命周期:

### 挂载

1. **解析协议** - 验证和处理 JSON 协议
2. **解析数据** - 从 API 获取数据或使用提供的值
3. **初始化状态** - 设置内部组件状态
4. **渲染** - 生成 UI

### 更新

1. **检测变化** - 监控数据、props 或状态变化
2. **重新评估表达式** - 更新模板表达式
3. **重新渲染** - 用新值更新 UI

### 卸载

1. **清理** - 取消待处理的请求,清除计时器
2. **移除** - 从 DOM 移除组件

## 组件组合

通过组合简单组件构建复杂 UI:

### 嵌套组件

```json
{
  "type": "page",
  "title": "仪表盘",
  "body": {
    "type": "grid",
    "columns": 3,
    "items": [
      {
        "type": "card",
        "title": "用户",
        "body": {
          "type": "text",
          "value": "${userCount}"
        }
      },
      {
        "type": "card",
        "title": "订单",
        "body": {
          "type": "text",
          "value": "${orderCount}"
        }
      },
      {
        "type": "card",
        "title": "收入",
        "body": {
          "type": "text",
          "value": "¥${revenue}"
        }
      }
    ]
  }
}
```

### 可复用组件

定义可复用的组件模板:

```typescript
// 定义模板
const userCard = (user) => ({
  type: 'card',
  title: user.name,
  body: [
    { type: 'text', value: `邮箱: ${user.email}` },
    { type: 'text', value: `角色: ${user.role}` }
  ]
})

// 使用模板
const protocol = {
  type: 'grid',
  columns: 2,
  items: users.map(userCard)
}
```

## 最佳实践

### 1. 保持协议简单

偏好简单、专注的组件而不是复杂的嵌套结构:

```json
// 好 - 简单专注
{
  "type": "form",
  "api": "/api/users",
  "fields": [...]
}

// 避免 - 太复杂
{
  "type": "page",
  "body": {
    "type": "grid",
    "items": [
      {
        "type": "card",
        "body": {
          "type": "form",
          // 深度嵌套...
        }
      }
    ]
  }
}
```

### 2. 明智使用模板表达式

保持表达式简单可读:

```json
// 好
{ "value": "${user.name}" }

// 避免 - 太复杂
{ "value": "${users.filter(u => u.active).map(u => u.name).join(', ')}" }
```

### 3. 利用操作

对所有交互使用操作:

```json
{
  "type": "button",
  "label": "删除",
  "onClick": {
    "type": "api",
    "api": "/api/delete",
    "confirm": "确定吗?"
  }
}
```

### 4. 提供反馈

始终为操作提供用户反馈:

```json
{
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "onSuccess": {
      "type": "toast",
      "message": "保存成功!"
    },
    "onError": {
      "type": "toast",
      "message": "保存失败",
      "variant": "error"
    }
  }
}
```

## 下一步

现在您已经理解了核心概念,继续探索:

- **[组件规范](/docs/03-objectui/component-spec)** - 完整的组件协议参考
- **[渲染器使用](/docs/03-objectui/renderer-usage)** - 在应用中集成 ObjectUI
