---
title: ObjectStack 宣言
description: 定义 ObjectStack 存在与演进的不可动摇的核心原则
---

# ObjectStack 宣言（The ObjectStack Manifesto）

ObjectStack 的存在是为了让数据应用开发回归本质。为了保持生态的健康与开放，我们承诺遵循以下不可动摇的核心原则：

## 第一条：协议中立原则（Protocol Neutrality）

### 原则

**ObjectQL 是中立的**：它不应该包含任何特定于语言（如 Node.js）、特定于数据库（如 MySQL）或特定于运行时（如 Electron）的逻辑。

### 标准优先

**Spec 先于 Engine**：任何功能必须先在 Spec（规范）层定义，然后才在 Engine（引擎）层实现。我们拒绝"先实现后标准化"的黑盒操作。

### 这意味着什么

ObjectStack 的协议层（ObjectQL、ObjectUI）是纯粹的规范定义，不包含任何具体实现。这确保了：

- ObjectQL 协议可以有多种实现（JavaScript、Python、Java 等）
- ObjectUI 协议可以有多种渲染器（React、Vue、Angular 等）
- 底层数据库可以随意切换（MySQL、PostgreSQL、Oracle 等）

### 实践指南

**协议设计时**：
- 使用标准的 JSON Schema 格式
- 避免引入特定语言或框架的概念
- 保持协议的简洁性和可扩展性
- 先在 Spec 层定义，再在 Engine 层实现

**实现开发时**：
- 严格遵循协议规范
- 通过测试套件验证协议兼容性
- 实现之间可以相互替换而不影响应用
- 不得将特定实现的逻辑泄漏到协议层

### 示例

```json
{
  "type": "query",
  "object": "users",
  "filters": {
    "age": { "$gt": 18 }
  },
  "sort": { "created_at": "desc" },
  "limit": 10
}
```

这个 ObjectQL 查询协议可以被：
- JavaScript 实现转译成 MySQL 查询
- Python 实现转译成 PostgreSQL 查询
- Java 实现转译成 Oracle 查询

**协议保持中立；实现可以替换。**

## 第二条：机制与实现分离（Mechanism over Policy）

### 原则

**ObjectQL 只提供机制**：它定义 `allowRead` 接口，但绝不强制规定用户数据必须存在哪里。

**ObjectOS 提供实现**：用户系统、文件存储、多租户逻辑属于 OS 层，严禁下沉污染 Protocol 层。

### 关注点分离

我们将"做什么"（机制）与"怎么做"（策略/实现）彻底分离。

开发者只需要：
- 定义数据模型（Schema）
- 定义界面结构（UI Protocol）
- 定义业务规则（Validation Rules）

而不需要关心：
- 数据如何存储
- 界面如何渲染
- 查询如何优化
- 权限如何执行

### 实践指南

**Schema 定义**（机制）：

```json
{
  "object": "orders",
  "fields": {
    "order_id": { "type": "text", "primary": true },
    "customer": { "type": "reference", "ref": "customers" },
    "total": { "type": "number" },
    "status": { "type": "select", "options": ["pending", "completed"] }
  },
  "permissions": {
    "allowRead": "{{ formula }}"
  }
}
```

协议定义**机制**（`allowRead` 接口），而 ObjectOS 提供**实现**（用户认证、数据过滤）。

开发者只需要定义数据模型和权限接口，系统自动：
- 创建数据库表结构
- 生成 CRUD API
- 提供数据验证
- 建立关系映射
- 执行权限规则

**UI 定义**（机制）：

```json
{
  "type": "page",
  "components": [
    {
      "type": "form",
      "fields": [
        { "name": "customer", "label": "客户", "type": "select" },
        { "name": "total", "label": "总额", "type": "number" }
      ]
    }
  ]
}
```

开发者只需要定义界面结构，系统自动：
- 渲染表单组件
- 处理数据绑定
- 执行表单验证
- 管理状态更新

### 为什么这很重要

1. **协议层保持纯粹**：ObjectQL 定义像 `allowRead` 这样的机制，而不是像"必须使用 JWT 认证"这样的策略
2. **实现灵活性**：ObjectOS 可以使用 JWT、OAuth 或自定义方案来实现用户系统
3. **无厂商锁定**：用户系统逻辑属于 OS 层，不硬编码在协议中
4. **清晰的边界**：机制（ObjectQL）与实现（ObjectOS）的分离被严格执行

### ❌ 我们拒绝的做法

**错误示例**：直接在 ObjectQL 协议中添加用户认证逻辑
```json
// ❌ 禁止：这污染了协议层
{
  "object": "users",
  "authentication": {
    "provider": "jwt",
    "secret": "hardcoded-secret"
  }
}
```

**正确示例**：ObjectQL 定义机制，ObjectOS 提供实现
```json
// ✅ 正确：协议定义机制
{
  "object": "users",
  "permissions": {
    "allowRead": "{{ currentUser.id === record.id }}"
  }
}

// ObjectOS 实现（独立层）处理：
// - "currentUser" 是什么？
// - 如何执行认证？
// - 用户数据存储在哪里？
```

## 第三条：数据主权原则（Data Sovereignty）

### 原则

**Local-First**：所有架构设计必须优先考虑"离线可用性"。任何依赖云端连接才能运行的核心功能，都是**被禁止的**。

**可移植性**：用户的数据（Schema + Data）必须能以标准文件格式（.oos / .json）导出，不锁定在任何特定厂商的云平台上。

### 核心理念

**"数据属于用户，而非平台"**

ObjectStack 坚持本地优先（Local-First）理念：
- 数据默认存储在用户本地
- 用户可以选择自己的数据库
- 没有强制性的云服务绑定
- 支持数据完全离线工作
- 保证完全的数据可移植性

### 实践指南

**本地优先架构**：

1. **单机模式**：
   - 使用 .oos 文件存储数据（基于 SQLite）
   - 数据完全在本地，无需网络
   - 适合个人应用场景
   - 设计上离线工作

2. **自托管模式**：
   - 部署到企业自己的服务器
   - 使用企业现有数据库（MySQL、Oracle 等）
   - 企业完全掌控数据
   - 不依赖外部服务

3. **混合模式**：
   - 本地优先，可选云同步
   - 支持端到端加密
   - 用户随时可以导出数据
   - 云是增强，而非必需

### 数据迁移自由

**零摩擦迁移**：

```bash
# 以标准格式导出数据
objectstack export --format json --output my-data.json

# 从 SQLite 迁移到 MySQL
objectstack migrate --from sqlite://app.oos --to mysql://localhost/mydb

# 从 MySQL 迁移到 PostgreSQL
objectstack migrate --from mysql://... --to postgresql://...

# 导出为可移植的 .oos 文件
objectstack export --format oos --output my-app.oos
```

由于协议层的抽象，数据可以在不同数据库之间自由迁移，没有厂商锁定。用户数据（Schema + Data）总是可以以标准格式导出。

### 什么是被禁止的

❌ **禁止**：需要云连接才能运行的核心功能
```
// ❌ 禁止
"此功能需要互联网连接才能使用"
"数据必须存储在我们的云服务器上"
"不支持离线模式"
```

✅ **必需**：核心功能必须离线工作
```
// ✅ 正确
"默认离线工作，云同步是可选的"
"数据存储在本地，您拥有并控制它"
"随时以 .oos 或 .json 格式导出您的数据"
```

### 隐私保护

- **字段级加密**：敏感字段可以加密存储
- **字段级权限**：细粒度的数据访问控制
- **审计日志**：完整的数据访问记录
- **数据擦除**：支持完全删除用户数据
- **无遥测锁定**：用户控制共享哪些数据

### 开源承诺

- 核心协议层（ObjectQL、ObjectUI）采用 MIT/Apache 2.0 开源许可
- 确保协议规范永久开放
- 社区可以自由实现兼容的引擎
- 避免单一厂商控制
- 数据格式公开记录且开放

## 第四条：向下兼容承诺（Stability Pledge）

### 原则

**作为底层基础设施，我们承诺 ObjectQL 核心语法的稳定性。**对于破坏性变更（Breaking Changes），我们将提供至少 2 个大版本的迁移窗口。

### 版本兼容性承诺

ObjectStack 不是一个普通的应用程序——它是基础设施。构建在 ObjectStack 之上的应用程序必须对其基础的稳定性充满信心。

**我们的承诺**：
1. **核心语法稳定**：ObjectQL 查询语法、Schema 定义和协议格式是稳定的
2. **迁移窗口**：破坏性变更需要至少 2 个主要版本的通知
3. **弃用路径**：标记为弃用的功能将至少支持 2 个主要版本
4. **向后兼容**：新功能是增量的，不是破坏性的

### 这在实践中意味着什么

**版本策略**：
- **补丁版本**（1.0.x）：仅修复错误，零破坏性变更
- **次要版本**（1.x.0）：新功能，向后兼容
- **主要版本**（x.0.0）：可能包含破坏性变更，但有迁移路径

**破坏性变更流程**：
1. **版本 N**：功能标记为弃用，添加警告
2. **版本 N+1**：弃用警告继续，提供迁移指南
3. **版本 N+2**：可以删除功能，但提供迁移工具

**示例时间线**：
```
v1.0.0: 功能 X 正常工作
v2.0.0: 功能 X 被弃用，添加警告
       "⚠️ 功能 X 已弃用，请改用功能 Y"
       X 和 Y 都可以工作
v3.0.0: 功能 X 仍然可以工作，但有警告
       提供迁移指南和自动化迁移工具
v4.0.0: 可以删除功能 X
       迁移工具继续可用
```

### 我们保证的内容

✅ **稳定核心**：
- ObjectQL 查询语法
- Schema 定义格式
- 协议消息结构
- 数据类型系统
- 权限模型接口

✅ **迁移支持**：
- 自动化迁移工具
- 全面的迁移指南
- 版本兼容性测试
- 迁移期间的社区支持

### 什么可以变更

以下内容可以在没有 2 版本窗口的情况下演进：
- **实现细节**：引擎内部如何执行查询
- **性能优化**：查询优化策略
- **新功能**：不破坏现有代码的增量功能
- **错误修复**：纠正非预期行为
- **文档**：澄清和改进

### 为什么这很重要

作为基础设施，ObjectStack 支撑着可能运行数年甚至数十年的应用程序。随意破坏兼容性会：
- ❌ 破坏对平台的信任
- ❌ 强迫用户进行昂贵的重写
- ❌ 在生态系统中造成碎片化
- ❌ 违反数据主权原则

我们的稳定性承诺确保：
- ✅ 对 ObjectStack 的长期信心
- ✅ 可预测的升级路径
- ✅ 更低的总拥有成本
- ✅ 生态系统的一致性

### 兼容性测试

每个 ObjectStack 版本都包括：
- 向后兼容性测试套件
- 迁移路径验证
- 版本兼容性矩阵
- 破坏性变更文档

## 不可动摇的基础

这四大原则不是技术细节——它们是 **ObjectStack 的核心价值观**：

1. **协议中立原则**：确保技术选型自由
2. **机制与实现分离**：确保架构清晰与灵活性
3. **数据主权原则**：确保用户权益和数据自由
4. **向下兼容承诺**：确保长期可靠性和信任

违背这些原则的功能，即使有短期利益，也**绝不**应该加入到 ObjectStack 中。

## 设计决策示例

### ✅ 符合宪法的设计

**场景**：添加全文搜索功能

**决策**：
- 在协议层定义统一的全文搜索语法（第一条：协议中立原则）
- 允许不同实现使用不同的搜索引擎（Elasticsearch、Meilisearch 等）
- 用户可以选择适合自己的搜索方案（第三条：数据主权原则）
- 保持搜索语法向后兼容（第四条：向下兼容承诺）

**为什么符合**：
- 协议层定义机制，而非实现
- 无厂商锁定
- 使用本地搜索索引离线工作
- 稳定、有文档的语法

### ❌ 违反宪法的设计

**场景**：添加云存储功能

**决策**：
- 强制使用某个特定的云服务商
- 数据必须上传到平台的服务器
- 不提供本地存储选项
- 核心功能需要互联网连接

**为什么违反**：
- ❌ 违反协议中立原则（第一条）：绑定特定服务商
- ❌ 违反数据主权原则（第三条）：强制云存储，需要互联网
- ❌ 违反本地优先要求：核心功能依赖云连接

**符合的替代方案**：
- 定义存储抽象协议
- 支持本地存储（SQLite、文件系统）作为默认
- 云存储作为可选插件
- 所有功能优先离线工作

## 实践检查清单

在设计新功能时，问自己：

**协议中立原则**：
- [ ] 这个功能是否先在 Spec 层定义？
- [ ] 是否避免了语言/数据库/运行时特定的逻辑？
- [ ] 是否可以有多种实现？

**机制与实现分离**：
- [ ] 是否定义了机制（接口）而非策略（实现）？
- [ ] 实现逻辑是否正确地分离到 ObjectOS 层？
- [ ] 是否避免了污染 Protocol 层？

**数据主权原则**：
- [ ] 是否离线工作（本地优先）？
- [ ] 用户是否可以以标准格式导出数据？
- [ ] 是否避免了厂商锁定？
- [ ] 用户是否保持对数据的完全控制？

**向下兼容承诺**：
- [ ] 是否向后兼容？
- [ ] 如果有破坏性变更，是否有 2 版本迁移路径？
- [ ] 变更是否有文档记录和迁移指南？

## 执行

本宪法通过以下方式执行：

1. **代码审查**：所有贡献必须符合这些原则
2. **架构审查**：主要功能根据宣言进行审查
3. **社区治理**：任何人都可以提出违反宣言的问题
4. **文档记录**：所有新功能都要记录符合宣言的理由

## 总结

ObjectStack 宣言不仅是技术指南——它是**价值观宣言**。它确保：

- **技术自由**：开发者可以选择最适合的技术栈
- **架构纯粹性**：机制与实现之间的清晰分离
- **数据自由**：用户完全拥有和控制自己的数据
- **进化自由**：系统可以持续演进而不破坏兼容性

这些原则是 ObjectStack 区别于其他平台的根本所在。它们是**不可动摇的**和**不可协商的**。

当有疑问时，回到这四大原则。它们是 ObjectStack 构建的基础，也是我们对所有在 ObjectStack 上构建的人的承诺。
