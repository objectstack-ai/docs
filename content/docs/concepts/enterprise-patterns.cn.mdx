---
title: 企业模式
description: 使用协议驱动方法处理复杂的 ERP/CRM 业务逻辑（状态机、计算、RBAC）。
---

# 企业模式

关于"低代码"或"协议驱动"平台，一个常见的误解是它们只适合简单的 CRUD 应用程序。

虽然这对许多可视化构建器是真实的，但 **ObjectStack** 的架构专门用于处理企业资源规划 (ERP) 和客户关系管理 (CRM) 系统的复杂性。我们处理复杂性的方式不是隐藏它，而是在协议中**明确建模**它。

以下是我们如何将常见的企业模式映射到 ObjectStack 架构的方法。

## 1. 工作流作为状态机 (FSM)

在企业软件中，一条记录（例如"采购订单"）很少只是静态数据。它是一个活的实体，会经历生命周期的不同阶段。

**反模式：**
在控制器中编写散乱的 `if/else` 逻辑：
```javascript
// 不要这样做
if (order.status === 'draft' && user.role === 'manager') {
  order.status = 'approved';
}

```

**ObjectStack 模式：**
我们在 ObjectOS Protocol 中将生命周期定义为**有限状态机 (FSM)**。这使业务流程具有确定性和可视化。

```yaml
# workflows/purchase_order.yaml
name: purchase_approval
object: purchase_order
states:
  draft:
    initial: true
    on_exit: ['validate_budget']
    transitions:
      submit: pending_approval
  pending_approval:
    transitions:
      approve: approved
      reject: rejected
    guards:
      approve: "user.has_permission('approve_budget')"
  approved:
    final: true

```

* **确定性：** 订单*不能*从 `draft` 跳转到 `shipped`，除非协议允许。
* **审计：** 引擎自动记录每个转换（谁移动它？何时？为什么？）。

## 2. 高精度计算（虚拟列）

ERP 本质上是数据库与复杂电子表格的混合体。您需要计算税费、汇总项目行和计算利润——通常跨越数百万行。

**反模式：**
将所有数据获取到 Node.js 内存中进行循环和计算。这会杀死性能。

**ObjectStack 模式：**
我们使用 **ObjectQL 虚拟列**将逻辑编译到数据库层。

```yaml
# objects/invoice.object.yaml
name: invoice
fields:
  lines:
    type: master_detail
    reference_to: invoice_line
  
  # 一个编译为 SQL 子查询或聚合的摘要字段
  total_amount:
    type: summary
    reference_to: lines
    summary_type: sum
    summary_field: amount
  
  # 一个编译为 SQL 表达式的公式字段
  margin_percent:
    type: formula
    formula: "(${total_amount} - ${cost}) / ${total_amount}"
    precision: 18
    scale: 2

```

* **性能：** ObjectQL 编译器将 `total_amount` 转换为高度优化的 SQL `SUM()` 或物化视图。
* **一致性：** 计算在 Schema 中定义一次，确保 API、UI 和报表都显示完全相同的数字。

## 3. 细粒度治理（字段级安全）

在人力资源系统中，每个人都可以看到"员工"记录，但只有人力资源经理才能看到"工资"字段。

**反模式：**
在 API 控制器中手动删除字段：`delete user.salary`。这容易出错；开发人员经常忘记一个端点（例如搜索 API）。

**ObjectStack 模式：**
安全性被注入到**编译阶段**。

```yaml
# permissions/hr_manager.permission.yaml
role: hr_manager
object: employee
allow_read: true
allow_edit: true
field_permissions:
  salary: 
    read: true
    edit: true

# permissions/employee.permission.yaml
role: employee
object: employee
allow_read: true
field_permissions:
  salary:
    read: false # 编译器从 SELECT 语句中物理移除此列

```

* **安全性：** 如果没有权限的用户尝试查询 `salary`，ObjectQL 引擎会抛出编译错误或返回 `null`（取决于配置）。它永远不会接触数据库。

## 4. 主从界面（复合 UI）

企业用户需要高密度的界面。他们需要在单个屏幕上编辑订单（头）及其项目（行），而无需页面刷新。

**ObjectStack 模式：**
ObjectUI 支持通过 JSON 定义的**复合布局**。

```json
{
  "type": "layout.master_detail",
  "props": {
    "master_object": "order",
    "detail_object": "order_line",
    "link_field": "order_id"
  },
  "children": [
    {
      "region": "header",
      "type": "form",
      "fields": ["customer", "date", "status"]
    },
    {
      "region": "body",
      "type": "grid.editable", // 类似 Excel 的可编辑表格
      "fields": ["product", "quantity", "price", "subtotal"]
    }
  ]
}

```

* **事务感知：** ObjectUI 引擎知道这两个数据集是链接的。当用户点击"保存"时，它会构造一个**事务变动**来原子性地保存订单和行。

## 5. 审计跟踪和合规性

对于财务和医疗保健（HIPAA/SOX），"谁改变了什么"是法律要求。

**ObjectStack 模式：**
因为所有变动都通过 ObjectQL Protocol 进行，所以通过一个标志就能启用审计。

* **协议：** 引擎捕获每个字段的 `before` 和 `after` 状态。
* **存储：** 变更被写入本地化的 `audit_log` 表（或不可变账本）。
* **可视化：** ObjectUI 提供内置的"历史"组件，可立即呈现此日志。

## 总结

ObjectStack 通过**将模式提升到协议**来处理企业复杂性。

| 复杂性 | 传统代码 | ObjectStack 协议 |
| --- | --- | --- |
| **流程** | `if/else` 意大利面条式代码 | **有限状态机 (YAML)** |
| **数学** | 内存中的循环 | **虚拟列 (SQL 编译)** |
| **保密** | 手动 API 过滤 | **引擎级 RBAC** |
| **用户体验** | 硬编码的 React 表单 | **主从布局 (JSON)** |
| **历史** | 自定义日志记录逻辑 | **原生审计跟踪** |
