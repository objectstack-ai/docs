---
title: ObjectStack 宣言
description: 管理 ObjectStack 的存在和演进的坚不可摧的核心原则
---

# ObjectStack 宣言

ObjectStack 的存在是为了将数据应用程序开发回归到其本质。为了维护健康和开放的生态系统，我们承诺坚守以下不可动摇的核心原则：

## 原则 I：协议中立性

### 原则

**ObjectQL 是中立的**：它不能包含任何特定于特定语言（例如 Node.js）、数据库（例如 MySQL）或运行时（例如 Electron）的逻辑。

### 标准优先

**规范优于引擎**：任何功能必须首先在规范层中定义，然后再在引擎层中实现。我们拒绝"先实现后标准化"的黑盒方法。

### 这意味着什么

ObjectStack 的协议层（ObjectQL、ObjectUI）完全由规范定义组成，没有具体实现。这确保：

- ObjectQL 协议可以有多个实现（JavaScript、Python、Java 等）
- ObjectUI 协议可以有多个渲染器（React、Vue、Angular 等）
- 底层数据库可以自由切换（MySQL、PostgreSQL、Oracle 等）

### 实践指南

**设计协议时**：
- 使用标准 JSON Schema 格式
- 避免引入特定于语言或概念的概念
- 保持协议简单且可扩展
- 先在规范层定义，再在引擎层实现

**开发实现时**：
- 严格遵循协议规范
- 通过测试套件验证协议兼容性
- 实现应该可互换，不影响应用程序
- 实现特定逻辑不应该泄露到协议层

### 示例

```json
{
  "type": "query",
  "object": "users",
  "filters": {
    "age": { "$gt": 18 }
  },
  "sort": { "created_at": "desc" },
  "limit": 10
}
```

这个 ObjectQL 查询协议可以：
- 由 JavaScript 实现编译为 MySQL 查询
- 由 Python 实现编译为 PostgreSQL 查询
- 由 Java 实现编译为 Oracle 查询

**协议保持中立；实现可替换。**

## 原则 II：机制优于策略

### 原则

**ObjectQL 只提供机制**：它定义 `allowRead` 接口，但从不规定用户数据必须存在的位置。

**ObjectOS 提供实现**：用户系统、文件存储和多租户逻辑属于 OS 层。用规范污染协议层是严格禁止的。

### 关注点分离

我们完全分离"做什么"（机制）和"如何做"（策略/实现）。

开发者只需要：
- 定义数据模型（Schema）
- 定义接口结构（UI Protocol）
- 定义业务规则（Validation Rules）

而无需担心：
- 数据如何存储
- 接口如何渲染
- 查询如何优化
- 权限如何执行

### 实践指南

**架构定义**（机制）：

```json
{
  "object": "orders",
  "fields": {
    "order_id": { "type": "text", "primary": true },
    "customer": { "type": "reference", "ref": "customers" },
    "total": { "type": "number" },
    "status": { "type": "select", "options": ["pending", "completed"] }
  },
  "permissions": {
    "allowRead": "{{ formula }}"
  }
}
```

协议定义**机制**（`allowRead` 接口），而 ObjectOS 提供**实现**（用户身份验证、数据过滤）。

开发者只需定义数据模型和权限接口，系统自动：
- 创建数据库表结构
- 生成 CRUD API
- 提供数据验证
- 建立关系映射
- 执行权限规则

**UI 定义**（机制）：

```json
{
  "type": "page",
  "components": [
    {
      "type": "form",
      "fields": [
        { "name": "customer", "label": "Customer", "type": "select" },
        { "name": "total", "label": "Total", "type": "number" }
      ]
    }
  ]
}
```

开发者只需定义接口结构，系统自动：
- 渲染表单组件
- 处理数据绑定
- 执行表单验证
- 管理状态更新

### 为什么这很重要

1. **协议层保持纯净**：ObjectQL 定义 `allowRead` 之类的机制，而不是"必须使用 JWT 认证"之类的策略
2. **实现灵活性**：ObjectOS 可以使用 JWT、OAuth 或自定义解决方案实现用户系统
3. **避免供应商锁定**：用户系统逻辑属于 OS 层，不硬编码在协议中
4. **清晰的边界**：严格执行机制（ObjectQL）与实现（ObjectOS）的分离

### ❌ 我们拒绝的

**坏示例**：直接将用户身份验证逻辑添加到 ObjectQL 协议
```json
// ❌ 禁止：这污染了协议层
{
  "object": "users",
  "authentication": {
    "provider": "jwt",
    "secret": "hardcoded-secret"
  }
}
```

**好示例**：ObjectQL 定义机制，ObjectOS 提供实现
```json
// ✅ 正确：协议定义机制
{
  "object": "users",
  "permissions": {
    "allowRead": "{{ currentUser.id === record.id }}"
  }
}

// ObjectOS 实现（独立层）处理：
// - 什么是 "currentUser"？
// - 如何执行身份验证？
// - 用户数据存储在哪里？
```

## 原则 III：数据主权

### 原则

**本地优先**：所有架构设计必须优先考虑"离线可用性"。任何依赖云连接才能运行的核心功能都是**禁止的**。

**便携性**：用户数据（Schema + Data）必须可以以标准文件格式（.oos / .json）导出，永远不会被锁定在任何特定供应商的云平台中。

### 核心哲学

**"数据属于用户，不属于平台"**

ObjectStack 遵循本地优先哲学：
- 数据默认存储在本地
- 用户可以选择自己的数据库
- 没有强制云服务绑定
- 支持完全离线数据操作
- 保证完整的数据便携性

### 实践指南

**本地优先架构**：

1. **独立模式**：
   - 使用 .oos 文件存储数据（基于 SQLite）
   - 数据完全本地，不需要网络
   - 适合个人应用场景
   - 设计上支持离线工作

2. **自托管模式**：
   - 部署到企业自己的服务器
   - 使用企业现有的数据库（MySQL、Oracle 等）
   - 企业完全控制数据
   - 不依赖外部服务

3. **混合模式**：
   - 本地优先加可选的云同步
   - 支持端到端加密
   - 用户可以随时导出数据
   - 云是增强功能，不是必需

### 数据迁移自由

**零摩擦迁移**：

```bash
# 以标准格式导出数据
objectstack export --format json --output my-data.json

# 从 SQLite 迁移到 MySQL
objectstack migrate --from sqlite://app.oos --to mysql://localhost/mydb

# 从 MySQL 迁移到 PostgreSQL
objectstack migrate --from mysql://... --to postgresql://...

# 导出为便携 .oos 文件
objectstack export --format oos --output my-app.oos
```

由于协议层抽象，数据可以自由地在不同数据库之间迁移，无需供应商锁定。用户数据（Schema + Data）总是可以以标准格式导出。

### 禁止的内容

❌ **禁止**：需要云连接的核心功能
```
// ❌ 禁止
"此功能需要网络连接才能工作"
"数据必须存储在我们的云服务器上"
"不支持离线模式"
```

✅ **必需**：核心功能必须支持离线
```
// ✅ 正确
"默认离线工作，云同步可选"
"数据存储在本地，您拥有和控制它"
"随时以 .oos 或 .json 格式导出您的数据"
```

### 隐私保护

- **字段级加密**：敏感字段可在存储中加密
- **字段级权限**：细粒度数据访问控制
- **审计日志**：完整的数据访问记录
- **数据删除**：支持完整的用户数据删除
- **无遥测锁定**：用户控制共享的数据

### 开源承诺

- 核心协议层（ObjectQL、ObjectUI）使用 MIT/Apache 2.0 开源许可
- 确保协议规范永久开放
- 社区可以自由实现兼容引擎
- 避免单一供应商控制
- 数据格式公开文档化和开放

## 原则 IV：稳定性承诺

### 原则

**作为基础设施，我们承诺 ObjectQL 核心语法的稳定性。** 对于破坏性变化，我们将提供至少 2 个主要版本的迁移窗口。

### 版本兼容性承诺

ObjectStack 不是典型的应用程序——它是基础设施。在 ObjectStack 上构建的应用程序必须相信其基础是稳定的。

**我们的承诺**：
1. **核心语法稳定性**：ObjectQL 查询语法、架构定义和协议格式是稳定的
2. **迁移窗口**：破坏性变化需要至少 2 个主要版本的通知
3. **弃用路径**：标记为弃用的功能将至少支持 2 个主要版本
4. **向后兼容性**：新功能是添加性的，不是破坏性的

### 这在实践中意味着什么

**版本策略**：
- **补丁版本** (1.0.x)：仅修复错误，零破坏性变化
- **次要版本** (1.x.0)：新功能，向后兼容
- **主要版本** (x.0.0)：可能包括破坏性变化，但有迁移路径

**破坏性变化流程**：
1. **版本 N**：功能标记为已弃用，添加警告
2. **版本 N+1**：弃用警告继续，提供迁移指南
3. **版本 N+2**：功能可以移除，但提供迁移工具

**示例时间线**：
```
v1.0.0: 功能 X 正常工作
v2.0.0: 功能 X 已弃用，添加警告
        "⚠️ 功能 X 已弃用，请改用功能 Y"
        X 和 Y 都能工作
v3.0.0: 功能 X 仍可工作但有警告
        提供迁移指南和自动迁移工具
v4.0.0: 功能 X 可以移除
        迁移工具继续工作
```

### 我们保证的

✅ **稳定核心**：
- ObjectQL 查询语法
- 架构定义格式
- 协议消息结构
- 数据类型系统
- 权限模型接口

✅ **迁移支持**：
- 自动迁移工具
- 全面的迁移指南
- 版本兼容性测试
- 迁移期间的社区支持

### 可以改变的内容

以下内容可以在不需要 2 版本窗口的情况下演进：
- **实现细节**：引擎如何在内部执行查询
- **性能优化**：查询优化策略
- **新功能**：不破坏现有代码的添加功能
- **错误修复**：对未预期行为的更正
- **文档**：澄清和改进

### 为什么这很重要

作为基础设施，ObjectStack 为可能存在多年甚至数十年的应用程序提供支持。随意破坏兼容性会：
- ❌ 摧毁对平台的信任
- ❌ 强制用户昂贵的重写
- ❌ 在生态系统中造成分裂
- ❌ 违反数据主权原则

我们的稳定性承诺确保：
- ✅ 对 ObjectStack 的长期信心
- ✅ 可预测的升级路径
- ✅ 更低的总体拥有成本
- ✅ 生态系统的一致性

### 兼容性测试

每个 ObjectStack 发布版本都包括：
- 向后兼容性测试套件
- 迁移路径验证
- 版本兼容性矩阵
- 破坏性变化文档

## 不可动摇的基础

这四个原则不是技术细节——它们是 **ObjectStack 的核心价值**：

1. **协议中立性**：确保技术选择的自由
2. **机制优于策略**：确保清晰的架构和灵活性
3. **数据主权**：确保用户权利和数据自由
4. **稳定性承诺**：确保长期的可靠性和信任

违反这些原则的功能，即使具有短期好处，**也不能**添加到 ObjectStack 中。

## 设计决策示例

### ✅ 符合规范的设计

**场景**：添加全文搜索功能

**决策**：
- 在协议层定义统一的全文搜索语法（原则 I：协议中立性）
- 允许不同的实现使用不同的搜索引擎（Elasticsearch、Meilisearch 等）
- 用户可以选择适合他们的搜索解决方案（原则 III：数据主权）
- 保持搜索语法向后兼容（原则 IV：稳定性承诺）

**为什么符合规范**：
- 协议层定义机制，不实现
- 没有供应商锁定
- 支持离线搜索索引
- 稳定、记录的语法

### ❌ 不符合规范的设计

**场景**：添加云存储功能

**决策**：
- 必须使用特定的云服务提供商
- 数据必须上传到平台服务器
- 不提供本地存储选项
- 核心功能需要网络连接

**为什么违反规范**：
- ❌ 违反协议中立性（原则 I）：绑定到特定供应商
- ❌ 违反数据主权（原则 III）：强制云存储，需要网络
- ❌ 违反本地优先授权：核心功能依赖云连接

**符合规范的替代方案**：
- 定义存储抽象协议
- 本地存储（SQLite、文件系统）作为默认
- 云存储作为可选插件
- 所有功能首先支持离线工作

## 实践检查清单

设计新功能时，问自己：

**协议中立性**：
- [ ] 此功能在规范层中首先定义了吗？
- [ ] 它是否避免了特定于语言/数据库/运行时的逻辑？
- [ ] 它能有多个实现吗？

**机制优于策略**：
- [ ] 它是否定义机制（接口）而不是策略（实现）？
- [ ] 实现逻辑是否正确分离到 ObjectOS 层？
- [ ] 它是否避免污染协议层？

**数据主权**：
- [ ] 它是否支持离线工作（本地优先）？
- [ ] 用户能否以标准格式导出其数据？
- [ ] 它是否避免供应商锁定？
- [ ] 用户是否保持完全控制其数据？

**稳定性承诺**：
- [ ] 它是否向后兼容？
- [ ] 如果破坏性，是否有 2 版本迁移路径？
- [ ] 变更是否有迁移指南文档？

## 执行

这份宣言通过以下方式执行：

1. **代码审查**：所有贡献必须符合这些原则
2. **架构审查**：主要功能针对宣言进行审查
3. **社区治理**：任何人都可以提出宣言违规
4. **文档**：所有新功能记录有宣言符合性原因

## 总结

ObjectStack 宣言不仅仅是技术指南——它是一份**价值声明**。它确保：

- **技术自由**：开发者可以选择最合适的技术栈
- **架构纯净**：机制和实现之间的清晰分离
- **数据自由**：用户完全拥有和控制其数据
- **演进自由**：系统可以持续演进，不破坏兼容性

这些原则从根本上将 ObjectStack 与其他平台区分开来。它们是**不可动摇的**和**不可协商的**。

如有疑问，回到这四个原则。它们是 ObjectStack 构建的基础，以及我们对每个在 ObjectStack 上构建的人所做的承诺。
