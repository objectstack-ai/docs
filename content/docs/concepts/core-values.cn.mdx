---
title: 核心价值
description: "深入探讨 ObjectStack 的三大支柱:协议驱动架构、本地优先数据主权和数据库无关性。"
---

# 核心价值

ObjectStack 建立在三个不可妥协的架构价值之上。这些不仅仅是"特性";它们是指导我们每个设计决策的约束。

## 1. 协议驱动: 意图优于实现

ObjectStack 的基本论点是**应用逻辑应该由声明式数据定义,而不是命令式代码。**

### "代码优先"的问题
在现代开发中,"意图"(例如,*"这个字段是必填的电子邮件地址"*)通常分散在三层:
1.  **数据库:** SQL 约束(`NOT NULL`)。
2.  **后端:** ORM 验证(例如 TypeORM 装饰器)。
3.  **前端:** UI 验证(例如 React Hook Form + Zod)。

当业务需求变更时,你必须在三个地方更新代码。这就是**实现耦合**。

### 协议驱动解决方案
ObjectStack 将"意图"集中到单个协议定义(JSON/YAML)中。实现层(React、Node.js、SQL)仅仅作为解释此协议的**运行时引擎**。



* **UI 是投影:** ObjectUI 不"构建"表单;它将 ObjectQL Schema *投影*成可视化表示。
* **API 是结果:** 你不需要编写端点;ObjectOS 基于访问控制协议*生成*安全图。

> **类比:** 将 ObjectStack 想象成 Web 浏览器。你向它发送 HTML(协议),它就渲染页面。你不需要每次想更改网站文本时都重写浏览器引擎(C++)。

## 2. 本地优先: 所有权与零延迟

在过去的十年中,"云原生"一直是黄金标准。虽然它解决了部署问题,但引入了一个新问题:**用户租用他们对数据的访问权。**

如果服务器慢,应用就慢。如果互联网断开,应用就死了。

### "七次跳转"问题
在传统的云应用中,一个简单的按钮点击要经过:
`点击 -> Wi-Fi -> ISP -> 云负载均衡器 -> Web 服务器 -> 数据库 -> 查询执行` ...然后一路返回。

### 本地优先解决方案
ObjectStack 应用被设计为首先读写**本地数据库**(嵌入在客户端环境中)。
`点击 -> 本地数据库 -> UI 更新`(0ms 延迟)。

与云的同步在后台异步进行。

1.  **即时响应:** UI 立即反应(乐观 UI),使企业应用感觉像原生桌面软件一样流畅。
2.  **离线能力:** 现场工作人员、飞机或不稳定的连接不再是障碍。
3.  **数据主权:** 数据物理上驻留在用户的设备上。云充当同步中心,而不是唯一的守门人。

## 3. 数据库无关: "通用编译器"

供应商锁定是长久性的敌人。业务应用通常比最初构建时使用的数据库技术存活时间更长。

ObjectQL 将底层数据库视为**实现细节**。

### 编译器方法
ObjectQL 不是运行时包装器(如 ORM),而是作为**编译器**运行。
1.  **输入:** ObjectQL 抽象语法树(AST)。
2.  **处理:** 将 AST 编译为特定方言的 SQL。
3.  **输出:** 针对目标的高度优化查询。

这种架构允许极大的灵活性:
* **开发环境:** 运行在 **SQLite** 上(零配置,单文件)。
* **生产环境:** 运行在 **PostgreSQL** 上(健壮,可扩展)。
* **边缘计算:** 运行在 **Cloudflare D1** 上(分布式)。
* **遗留系统:** 连接到现有的 **Oracle/SQL Server**(集成)。

你改变*驱动程序*,而不是*代码*。

## 总结

| 价值 | 旧方式 | ObjectStack 方式 |
| :--- | :--- | :--- |
| **架构** | 代码驱动(命令式) | 协议驱动(声明式) |
| **逻辑位置** | 分散(DB + API + UI) | 集中化(JSON/YAML Schema) |
| **数据访问** | 云依赖(仅在线) | 本地优先(离线 + 同步) |
| **存储** | 供应商锁定 | 数据库无关 |

通过遵循这些价值观,我们构建的软件**能够抵御变化**,**尊重用户时间**,并且**在技术上独立自主**。
