---
title: Core Concepts
description: Understanding declarative UI, data-driven rendering, and ObjectUI principles
---

# Core Concepts

This guide explains the fundamental concepts that power ObjectUI's declarative and data-driven architecture.

## Declarative UI vs Imperative UI

Understanding the difference between declarative and imperative approaches is key to mastering ObjectUI.

### Imperative UI

In traditional imperative UI development, you write code that describes **how** to build and update the interface:

```tsx
// Imperative approach - describes HOW
function UserProfile() {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [])
  
  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error}</div>
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => {
        fetch('/api/user', { method: 'DELETE' })
          .then(() => window.location.href = '/users')
      }}>
        Delete User
      </button>
    </div>
  )
}
```

**Characteristics:**
- You manage state (`useState`, `useEffect`)
- You handle data fetching manually
- You write event handlers
- You control rendering logic
- More code, more maintenance

### Declarative UI

In ObjectUI's declarative approach, you describe **what** you want, not how to build it:

```json
{
  "type": "card",
  "title": "${name}",
  "api": "/api/user",
  "body": [
    { "type": "text", "value": "Email: ${email}" }
  ],
  "actions": [
    {
      "label": "Delete User",
      "api": "/api/user",
      "method": "DELETE",
      "confirm": "Are you sure?",
      "onSuccess": { "type": "redirect", "url": "/users" }
    }
  ]
}
```

**Characteristics:**
- No state management code
- Automatic data fetching
- Declarative actions
- Built-in error handling
- Less code, easier maintenance

### Benefits of Declarative UI

1. **Simplicity** - Describe what you want, not how to build it
2. **Consistency** - All components follow the same patterns
3. **Maintainability** - Less code means fewer bugs
4. **Flexibility** - UI can be modified without code changes
5. **Portability** - JSON protocols can be stored, versioned, and shared
6. **Dynamic Generation** - UI can be generated programmatically or from database

## Data-Driven Rendering

ObjectUI components are **data-driven**, meaning the UI automatically reflects the underlying data.

### The Data Flow

```
┌──────────────┐
│   Protocol   │  → Defines structure and behavior
│    (JSON)    │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│     Data     │  → Provides content
│   (API/Props)│
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  Rendered UI │  → Automatic rendering
│              │
└──────────────┘
```

### Data Sources

ObjectUI components can receive data from multiple sources:

#### 1. API Endpoints

Fetch data automatically from APIs:

```json
{
  "type": "table",
  "api": "/api/users",
  "columns": [
    { "name": "name", "label": "Name" },
    { "name": "email", "label": "Email" }
  ]
}
```

The component:
- Fetches data from `/api/users` on mount
- Handles loading states
- Displays errors if request fails
- Re-fetches on parameter changes

#### 2. Static Data

Provide data directly in the protocol:

```json
{
  "type": "select",
  "name": "priority",
  "label": "Priority",
  "options": [
    { "label": "High", "value": "high" },
    { "label": "Medium", "value": "medium" },
    { "label": "Low", "value": "low" }
  ]
}
```

#### 3. Context Data

Access data from parent components:

```json
{
  "type": "form",
  "api": "/api/users/${userId}",
  "fields": [
    { "name": "name", "type": "input" },
    { "name": "email", "type": "input" }
  ]
}
```

`${userId}` is resolved from the context (URL params, parent state, etc.)

### Reactive Updates

When data changes, the UI automatically updates:

```json
{
  "type": "card",
  "api": "/api/stats",
  "refresh": 5000,
  "body": [
    { "type": "text", "value": "Active Users: ${activeUsers}" },
    { "type": "text", "value": "Total Orders: ${totalOrders}" }
  ]
}
```

This card:
- Fetches initial data from `/api/stats`
- Automatically refreshes every 5 seconds
- Updates displayed values when data changes

## Protocol Structure

Every ObjectUI component follows a consistent protocol structure:

### Basic Protocol

```typescript
{
  // Component type (required)
  type: 'input' | 'select' | 'table' | 'form' | 'page' | ...,
  
  // Common properties
  name?: string,           // Field name for forms
  label?: string,          // Display label
  visible?: boolean,       // Visibility control
  disabled?: boolean,      // Disabled state
  
  // Data properties
  value?: any,            // Static value
  defaultValue?: any,     // Default value
  api?: string,           // API endpoint for data
  
  // Event handlers
  onChange?: Action,      // Change handler
  onClick?: Action,       // Click handler
  
  // Styling
  className?: string,     // CSS class
  style?: object,         // Inline styles
}
```

### Component-Specific Properties

Each component type has additional specific properties:

```json
{
  "type": "input",
  "placeholder": "Enter text...",
  "maxLength": 100
}
```

```json
{
  "type": "table",
  "columns": [...],
  "pagination": true,
  "pageSize": 20
}
```

## Template Expressions

ObjectUI supports template expressions for dynamic values:

### Simple Variable

```json
{
  "type": "text",
  "value": "Hello, ${userName}!"
}
```

### Nested Properties

```json
{
  "type": "text",
  "value": "${user.profile.firstName} ${user.profile.lastName}"
}
```

### Conditional Display

```json
{
  "type": "badge",
  "value": "${status}",
  "visible": "${status === 'active'}"
}
```

### Array Access

```json
{
  "type": "text",
  "value": "First item: ${items[0].name}"
}
```

## Actions

Actions define interactive behavior in ObjectUI:

### Action Types

#### 1. API Request

Make HTTP requests:

```json
{
  "type": "button",
  "label": "Submit",
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "method": "POST",
    "data": "${formData}"
  }
}
```

#### 2. Navigation

Navigate to different pages:

```json
{
  "type": "button",
  "label": "View Details",
  "onClick": {
    "type": "navigate",
    "url": "/users/${id}"
  }
}
```

#### 3. Dialog

Open dialogs or modals:

```json
{
  "type": "button",
  "label": "Edit",
  "onClick": {
    "type": "dialog",
    "title": "Edit User",
    "body": {
      "type": "form",
      "fields": [...]
    }
  }
}
```

#### 4. Toast/Message

Show notifications:

```json
{
  "type": "button",
  "label": "Save",
  "onClick": {
    "type": "toast",
    "message": "Saved successfully!",
    "variant": "success"
  }
}
```

#### 5. Set State

Update component state:

```json
{
  "type": "button",
  "label": "Toggle",
  "onClick": {
    "type": "setState",
    "key": "isExpanded",
    "value": "${!isExpanded}"
  }
}
```

### Action Chains

Execute multiple actions in sequence:

```json
{
  "type": "button",
  "label": "Delete",
  "onClick": [
    {
      "type": "api",
      "api": "/api/users/${id}",
      "method": "DELETE"
    },
    {
      "type": "toast",
      "message": "User deleted"
    },
    {
      "type": "navigate",
      "url": "/users"
    }
  ]
}
```

### Conditional Actions

Execute actions based on conditions:

```json
{
  "type": "button",
  "label": "Submit",
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "method": "POST",
    "onSuccess": {
      "type": "toast",
      "message": "Success!"
    },
    "onError": {
      "type": "toast",
      "message": "Error: ${error}",
      "variant": "error"
    }
  }
}
```

## Component Lifecycle

ObjectUI components have a predictable lifecycle:

### Mount

1. **Parse protocol** - Validate and process the JSON protocol
2. **Resolve data** - Fetch data from API or use provided values
3. **Initialize state** - Set up internal component state
4. **Render** - Generate the UI

### Update

1. **Detect changes** - Monitor data, props, or state changes
2. **Re-evaluate expressions** - Update template expressions
3. **Re-render** - Update the UI with new values

### Unmount

1. **Cleanup** - Cancel pending requests, clear timers
2. **Remove** - Remove component from DOM

## Component Composition

Build complex UIs by composing simple components:

### Nested Components

```json
{
  "type": "page",
  "title": "Dashboard",
  "body": {
    "type": "grid",
    "columns": 3,
    "items": [
      {
        "type": "card",
        "title": "Users",
        "body": {
          "type": "text",
          "value": "${userCount}"
        }
      },
      {
        "type": "card",
        "title": "Orders",
        "body": {
          "type": "text",
          "value": "${orderCount}"
        }
      },
      {
        "type": "card",
        "title": "Revenue",
        "body": {
          "type": "text",
          "value": "$${revenue}"
        }
      }
    ]
  }
}
```

### Reusable Components

Define reusable component templates:

```typescript
// Define template
const userCard = (user) => ({
  type: 'card',
  title: user.name,
  body: [
    { type: 'text', value: `Email: ${user.email}` },
    { type: 'text', value: `Role: ${user.role}` }
  ]
})

// Use template
const protocol = {
  type: 'grid',
  columns: 2,
  items: users.map(userCard)
}
```

## Best Practices

### 1. Keep Protocols Simple

Prefer simple, focused components over complex nested structures:

```json
// Good - Simple and focused
{
  "type": "form",
  "api": "/api/users",
  "fields": [...]
}

// Avoid - Too complex
{
  "type": "page",
  "body": {
    "type": "grid",
    "items": [
      {
        "type": "card",
        "body": {
          "type": "form",
          // Deeply nested...
        }
      }
    ]
  }
}
```

### 2. Use Template Expressions Wisely

Keep expressions simple and readable:

```json
// Good
{ "value": "${user.name}" }

// Avoid - Too complex
{ "value": "${users.filter(u => u.active).map(u => u.name).join(', ')}" }
```

### 3. Leverage Actions

Use actions for all interactions:

```json
{
  "type": "button",
  "label": "Delete",
  "onClick": {
    "type": "api",
    "api": "/api/delete",
    "confirm": "Are you sure?"
  }
}
```

### 4. Provide Feedback

Always provide user feedback for actions:

```json
{
  "onClick": {
    "type": "api",
    "api": "/api/submit",
    "onSuccess": {
      "type": "toast",
      "message": "Saved successfully!"
    },
    "onError": {
      "type": "toast",
      "message": "Failed to save",
      "variant": "error"
    }
  }
}
```

## Next Steps

Now that you understand the core concepts, explore:

- **[Component Spec](./component-spec)** - Complete component protocol reference
- **[Renderer Usage](./renderer-usage)** - Integrate ObjectUI in your application
